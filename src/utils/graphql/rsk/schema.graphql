directive @entity on OBJECT

directive @derivedFrom(field: String) on FIELD_DEFINITION

directive @subgraphId(id: String) on OBJECT

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow {
  id: ID!
  user: User!
  lender: Bytes!
  loanId: Loan!
  loanToken: Bytes!
  collateralToken: Bytes!
  newPrincipal: BigInt!
  newCollateral: BigInt!
  interestRate: BigInt!
  interestDuration: BigInt!
  collateralToLoanRate: BigInt!
  currentMargin: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input Borrow_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lender: Bytes
  lender_not: Bytes
  lender_in: [Bytes!]
  lender_not_in: [Bytes!]
  lender_contains: Bytes
  lender_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  loanToken: Bytes
  loanToken_not: Bytes
  loanToken_in: [Bytes!]
  loanToken_not_in: [Bytes!]
  loanToken_contains: Bytes
  loanToken_not_contains: Bytes
  collateralToken: Bytes
  collateralToken_not: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not_in: [Bytes!]
  collateralToken_contains: Bytes
  collateralToken_not_contains: Bytes
  newPrincipal: BigInt
  newPrincipal_not: BigInt
  newPrincipal_gt: BigInt
  newPrincipal_lt: BigInt
  newPrincipal_gte: BigInt
  newPrincipal_lte: BigInt
  newPrincipal_in: [BigInt!]
  newPrincipal_not_in: [BigInt!]
  newCollateral: BigInt
  newCollateral_not: BigInt
  newCollateral_gt: BigInt
  newCollateral_lt: BigInt
  newCollateral_gte: BigInt
  newCollateral_lte: BigInt
  newCollateral_in: [BigInt!]
  newCollateral_not_in: [BigInt!]
  interestRate: BigInt
  interestRate_not: BigInt
  interestRate_gt: BigInt
  interestRate_lt: BigInt
  interestRate_gte: BigInt
  interestRate_lte: BigInt
  interestRate_in: [BigInt!]
  interestRate_not_in: [BigInt!]
  interestDuration: BigInt
  interestDuration_not: BigInt
  interestDuration_gt: BigInt
  interestDuration_lt: BigInt
  interestDuration_gte: BigInt
  interestDuration_lte: BigInt
  interestDuration_in: [BigInt!]
  interestDuration_not_in: [BigInt!]
  collateralToLoanRate: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_not_in: [BigInt!]
  currentMargin: BigInt
  currentMargin_not: BigInt
  currentMargin_gt: BigInt
  currentMargin_lt: BigInt
  currentMargin_gte: BigInt
  currentMargin_lte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum Borrow_orderBy {
  id
  user
  lender
  loanId
  loanToken
  collateralToken
  newPrincipal
  newCollateral
  interestRate
  interestDuration
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}

scalar Bytes

type CandleStick {
  id: ID!
  baseToken: Token
  quoteToken: Token
  interval: CandleSticksInterval
  open: BigDecimal
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  txCount: Int!
  totalVolume: BigDecimal!
  periodStartUnix: Int!
}

input CandleStick_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  baseToken: String
  baseToken_not: String
  baseToken_gt: String
  baseToken_lt: String
  baseToken_gte: String
  baseToken_lte: String
  baseToken_in: [String!]
  baseToken_not_in: [String!]
  baseToken_contains: String
  baseToken_not_contains: String
  baseToken_starts_with: String
  baseToken_not_starts_with: String
  baseToken_ends_with: String
  baseToken_not_ends_with: String
  quoteToken: String
  quoteToken_not: String
  quoteToken_gt: String
  quoteToken_lt: String
  quoteToken_gte: String
  quoteToken_lte: String
  quoteToken_in: [String!]
  quoteToken_not_in: [String!]
  quoteToken_contains: String
  quoteToken_not_contains: String
  quoteToken_starts_with: String
  quoteToken_not_starts_with: String
  quoteToken_ends_with: String
  quoteToken_not_ends_with: String
  interval: CandleSticksInterval
  interval_not: CandleSticksInterval
  interval_in: [CandleSticksInterval!]
  interval_not_in: [CandleSticksInterval!]
  open: BigDecimal
  open_not: BigDecimal
  open_gt: BigDecimal
  open_lt: BigDecimal
  open_gte: BigDecimal
  open_lte: BigDecimal
  open_in: [BigDecimal!]
  open_not_in: [BigDecimal!]
  high: BigDecimal
  high_not: BigDecimal
  high_gt: BigDecimal
  high_lt: BigDecimal
  high_gte: BigDecimal
  high_lte: BigDecimal
  high_in: [BigDecimal!]
  high_not_in: [BigDecimal!]
  low: BigDecimal
  low_not: BigDecimal
  low_gt: BigDecimal
  low_lt: BigDecimal
  low_gte: BigDecimal
  low_lte: BigDecimal
  low_in: [BigDecimal!]
  low_not_in: [BigDecimal!]
  close: BigDecimal
  close_not: BigDecimal
  close_gt: BigDecimal
  close_lt: BigDecimal
  close_gte: BigDecimal
  close_lte: BigDecimal
  close_in: [BigDecimal!]
  close_not_in: [BigDecimal!]
  txCount: Int
  txCount_not: Int
  txCount_gt: Int
  txCount_lt: Int
  txCount_gte: Int
  txCount_lte: Int
  txCount_in: [Int!]
  txCount_not_in: [Int!]
  totalVolume: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_lt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_not_in: [BigDecimal!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
}

enum CandleStick_orderBy {
  id
  baseToken
  quoteToken
  interval
  open
  high
  low
  close
  txCount
  totalVolume
  periodStartUnix
}

enum CandleSticksInterval {
  MinuteInterval
  FifteenMintuesInterval
  HourInterval
  FourHourInterval
  DayInterval
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit {
  id: ID!
  user: Bytes!
  lender: Bytes!
  loanId: Loan!
  closer: Bytes!
  loanToken: Bytes!
  collateralToken: Bytes!
  repayAmount: BigInt!
  collateralWithdrawAmount: BigInt!
  collateralToLoanRate: BigInt!
  currentMargin: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input CloseWithDeposit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: Bytes
  user_not: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  lender: Bytes
  lender_not: Bytes
  lender_in: [Bytes!]
  lender_not_in: [Bytes!]
  lender_contains: Bytes
  lender_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  closer: Bytes
  closer_not: Bytes
  closer_in: [Bytes!]
  closer_not_in: [Bytes!]
  closer_contains: Bytes
  closer_not_contains: Bytes
  loanToken: Bytes
  loanToken_not: Bytes
  loanToken_in: [Bytes!]
  loanToken_not_in: [Bytes!]
  loanToken_contains: Bytes
  loanToken_not_contains: Bytes
  collateralToken: Bytes
  collateralToken_not: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not_in: [Bytes!]
  collateralToken_contains: Bytes
  collateralToken_not_contains: Bytes
  repayAmount: BigInt
  repayAmount_not: BigInt
  repayAmount_gt: BigInt
  repayAmount_lt: BigInt
  repayAmount_gte: BigInt
  repayAmount_lte: BigInt
  repayAmount_in: [BigInt!]
  repayAmount_not_in: [BigInt!]
  collateralWithdrawAmount: BigInt
  collateralWithdrawAmount_not: BigInt
  collateralWithdrawAmount_gt: BigInt
  collateralWithdrawAmount_lt: BigInt
  collateralWithdrawAmount_gte: BigInt
  collateralWithdrawAmount_lte: BigInt
  collateralWithdrawAmount_in: [BigInt!]
  collateralWithdrawAmount_not_in: [BigInt!]
  collateralToLoanRate: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_not_in: [BigInt!]
  currentMargin: BigInt
  currentMargin_not: BigInt
  currentMargin_gt: BigInt
  currentMargin_lt: BigInt
  currentMargin_gte: BigInt
  currentMargin_lte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum CloseWithDeposit_orderBy {
  id
  user
  lender
  loanId
  closer
  loanToken
  collateralToken
  repayAmount
  collateralWithdrawAmount
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap {
  id: ID!
  user: Bytes!
  lender: Bytes!
  loanId: Loan!
  collateralToken: Bytes!
  loanToken: Bytes!
  closer: Bytes!
  positionCloseSize: BigInt!
  loanCloseAmount: BigInt!
  exitPrice: BigInt!
  currentLeverage: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input CloseWithSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: Bytes
  user_not: Bytes
  user_in: [Bytes!]
  user_not_in: [Bytes!]
  user_contains: Bytes
  user_not_contains: Bytes
  lender: Bytes
  lender_not: Bytes
  lender_in: [Bytes!]
  lender_not_in: [Bytes!]
  lender_contains: Bytes
  lender_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  collateralToken: Bytes
  collateralToken_not: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not_in: [Bytes!]
  collateralToken_contains: Bytes
  collateralToken_not_contains: Bytes
  loanToken: Bytes
  loanToken_not: Bytes
  loanToken_in: [Bytes!]
  loanToken_not_in: [Bytes!]
  loanToken_contains: Bytes
  loanToken_not_contains: Bytes
  closer: Bytes
  closer_not: Bytes
  closer_in: [Bytes!]
  closer_not_in: [Bytes!]
  closer_contains: Bytes
  closer_not_contains: Bytes
  positionCloseSize: BigInt
  positionCloseSize_not: BigInt
  positionCloseSize_gt: BigInt
  positionCloseSize_lt: BigInt
  positionCloseSize_gte: BigInt
  positionCloseSize_lte: BigInt
  positionCloseSize_in: [BigInt!]
  positionCloseSize_not_in: [BigInt!]
  loanCloseAmount: BigInt
  loanCloseAmount_not: BigInt
  loanCloseAmount_gt: BigInt
  loanCloseAmount_lt: BigInt
  loanCloseAmount_gte: BigInt
  loanCloseAmount_lte: BigInt
  loanCloseAmount_in: [BigInt!]
  loanCloseAmount_not_in: [BigInt!]
  exitPrice: BigInt
  exitPrice_not: BigInt
  exitPrice_gt: BigInt
  exitPrice_lt: BigInt
  exitPrice_gte: BigInt
  exitPrice_lte: BigInt
  exitPrice_in: [BigInt!]
  exitPrice_not_in: [BigInt!]
  currentLeverage: BigInt
  currentLeverage_not: BigInt
  currentLeverage_gt: BigInt
  currentLeverage_lt: BigInt
  currentLeverage_gte: BigInt
  currentLeverage_lte: BigInt
  currentLeverage_in: [BigInt!]
  currentLeverage_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum CloseWithSwap_orderBy {
  id
  user
  lender
  loanId
  collateralToken
  loanToken
  closer
  positionCloseSize
  loanCloseAmount
  exitPrice
  currentLeverage
  timestamp
  emittedBy
  transaction
}

"""
Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep
"""
type Conversion {
  id: ID!
  _fromToken: Token!
  _toToken: Token!
  _trader: Bytes!
  _amount: BigInt!
  _return: BigInt!
  _conversionFee: BigInt!
  _protocolFee: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
  swapTransaction: Swap!
}

input Conversion_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _fromToken: String
  _fromToken_not: String
  _fromToken_gt: String
  _fromToken_lt: String
  _fromToken_gte: String
  _fromToken_lte: String
  _fromToken_in: [String!]
  _fromToken_not_in: [String!]
  _fromToken_contains: String
  _fromToken_not_contains: String
  _fromToken_starts_with: String
  _fromToken_not_starts_with: String
  _fromToken_ends_with: String
  _fromToken_not_ends_with: String
  _toToken: String
  _toToken_not: String
  _toToken_gt: String
  _toToken_lt: String
  _toToken_gte: String
  _toToken_lte: String
  _toToken_in: [String!]
  _toToken_not_in: [String!]
  _toToken_contains: String
  _toToken_not_contains: String
  _toToken_starts_with: String
  _toToken_not_starts_with: String
  _toToken_ends_with: String
  _toToken_not_ends_with: String
  _trader: Bytes
  _trader_not: Bytes
  _trader_in: [Bytes!]
  _trader_not_in: [Bytes!]
  _trader_contains: Bytes
  _trader_not_contains: Bytes
  _amount: BigInt
  _amount_not: BigInt
  _amount_gt: BigInt
  _amount_lt: BigInt
  _amount_gte: BigInt
  _amount_lte: BigInt
  _amount_in: [BigInt!]
  _amount_not_in: [BigInt!]
  _return: BigInt
  _return_not: BigInt
  _return_gt: BigInt
  _return_lt: BigInt
  _return_gte: BigInt
  _return_lte: BigInt
  _return_in: [BigInt!]
  _return_not_in: [BigInt!]
  _conversionFee: BigInt
  _conversionFee_not: BigInt
  _conversionFee_gt: BigInt
  _conversionFee_lt: BigInt
  _conversionFee_gte: BigInt
  _conversionFee_lte: BigInt
  _conversionFee_in: [BigInt!]
  _conversionFee_not_in: [BigInt!]
  _protocolFee: BigInt
  _protocolFee_not: BigInt
  _protocolFee_gt: BigInt
  _protocolFee_lt: BigInt
  _protocolFee_gte: BigInt
  _protocolFee_lte: BigInt
  _protocolFee_in: [BigInt!]
  _protocolFee_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  swapTransaction: String
  swapTransaction_not: String
  swapTransaction_gt: String
  swapTransaction_lt: String
  swapTransaction_gte: String
  swapTransaction_lte: String
  swapTransaction_in: [String!]
  swapTransaction_not_in: [String!]
  swapTransaction_contains: String
  swapTransaction_not_contains: String
  swapTransaction_starts_with: String
  swapTransaction_not_starts_with: String
  swapTransaction_ends_with: String
  swapTransaction_not_ends_with: String
}

enum Conversion_orderBy {
  id
  _fromToken
  _toToken
  _trader
  _amount
  _return
  _conversionFee
  _protocolFee
  timestamp
  emittedBy
  transaction
  swapTransaction
}

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry {
  """
  ID is the address of the converter registry contract
  """
  id: ID!

  """
  All the converters (AMM pools) associated with this registry
  """
  converters(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter
  ): [LiquidityPool!]
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    where: SmartToken_filter
  ): [SmartToken!]
  connectorTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
  ): [Token!]
  owner: Bytes!
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: BigInt
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: BigInt
  numConverters: BigInt!
}

input ConverterRegistry_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: Bytes
  owner_not: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  addedToContractRegistryAtBlockTimestamp: BigInt
  addedToContractRegistryAtBlockTimestamp_not: BigInt
  addedToContractRegistryAtBlockTimestamp_gt: BigInt
  addedToContractRegistryAtBlockTimestamp_lt: BigInt
  addedToContractRegistryAtBlockTimestamp_gte: BigInt
  addedToContractRegistryAtBlockTimestamp_lte: BigInt
  addedToContractRegistryAtBlockTimestamp_in: [BigInt!]
  addedToContractRegistryAtBlockTimestamp_not_in: [BigInt!]
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtTransactionHash_not: String
  addedToContractRegistryAtTransactionHash_gt: String
  addedToContractRegistryAtTransactionHash_lt: String
  addedToContractRegistryAtTransactionHash_gte: String
  addedToContractRegistryAtTransactionHash_lte: String
  addedToContractRegistryAtTransactionHash_in: [String!]
  addedToContractRegistryAtTransactionHash_not_in: [String!]
  addedToContractRegistryAtTransactionHash_contains: String
  addedToContractRegistryAtTransactionHash_not_contains: String
  addedToContractRegistryAtTransactionHash_starts_with: String
  addedToContractRegistryAtTransactionHash_not_starts_with: String
  addedToContractRegistryAtTransactionHash_ends_with: String
  addedToContractRegistryAtTransactionHash_not_ends_with: String
  addedToContractRegistryAtBlockNumber: BigInt
  addedToContractRegistryAtBlockNumber_not: BigInt
  addedToContractRegistryAtBlockNumber_gt: BigInt
  addedToContractRegistryAtBlockNumber_lt: BigInt
  addedToContractRegistryAtBlockNumber_gte: BigInt
  addedToContractRegistryAtBlockNumber_lte: BigInt
  addedToContractRegistryAtBlockNumber_in: [BigInt!]
  addedToContractRegistryAtBlockNumber_not_in: [BigInt!]
  lastUsedAtBlockTimestamp: BigInt
  lastUsedAtBlockTimestamp_not: BigInt
  lastUsedAtBlockTimestamp_gt: BigInt
  lastUsedAtBlockTimestamp_lt: BigInt
  lastUsedAtBlockTimestamp_gte: BigInt
  lastUsedAtBlockTimestamp_lte: BigInt
  lastUsedAtBlockTimestamp_in: [BigInt!]
  lastUsedAtBlockTimestamp_not_in: [BigInt!]
  lastUsedAtTransactionHash: String
  lastUsedAtTransactionHash_not: String
  lastUsedAtTransactionHash_gt: String
  lastUsedAtTransactionHash_lt: String
  lastUsedAtTransactionHash_gte: String
  lastUsedAtTransactionHash_lte: String
  lastUsedAtTransactionHash_in: [String!]
  lastUsedAtTransactionHash_not_in: [String!]
  lastUsedAtTransactionHash_contains: String
  lastUsedAtTransactionHash_not_contains: String
  lastUsedAtTransactionHash_starts_with: String
  lastUsedAtTransactionHash_not_starts_with: String
  lastUsedAtTransactionHash_ends_with: String
  lastUsedAtTransactionHash_not_ends_with: String
  lastUsedAtBlockNumber: BigInt
  lastUsedAtBlockNumber_not: BigInt
  lastUsedAtBlockNumber_gt: BigInt
  lastUsedAtBlockNumber_lt: BigInt
  lastUsedAtBlockNumber_gte: BigInt
  lastUsedAtBlockNumber_lte: BigInt
  lastUsedAtBlockNumber_in: [BigInt!]
  lastUsedAtBlockNumber_not_in: [BigInt!]
  numConverters: BigInt
  numConverters_not: BigInt
  numConverters_gt: BigInt
  numConverters_lt: BigInt
  numConverters_gte: BigInt
  numConverters_lte: BigInt
  numConverters_in: [BigInt!]
  numConverters_not_in: [BigInt!]
}

enum ConverterRegistry_orderBy {
  id
  converters
  smartTokens
  connectorTokens
  owner
  addedToContractRegistryAtBlockTimestamp
  addedToContractRegistryAtTransactionHash
  addedToContractRegistryAtBlockNumber
  lastUsedAtBlockTimestamp
  lastUsedAtTransactionHash
  lastUsedAtBlockNumber
  numConverters
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral {
  id: ID!
  loanId: Loan!
  depositAmount: BigInt!
  rate: BigInt
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input DepositCollateral_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  depositAmount: BigInt
  depositAmount_not: BigInt
  depositAmount_gt: BigInt
  depositAmount_lt: BigInt
  depositAmount_gte: BigInt
  depositAmount_lte: BigInt
  depositAmount_in: [BigInt!]
  depositAmount_not_in: [BigInt!]
  rate: BigInt
  rate_not: BigInt
  rate_gt: BigInt
  rate_lt: BigInt
  rate_gte: BigInt
  rate_lte: BigInt
  rate_in: [BigInt!]
  rate_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum DepositCollateral_orderBy {
  id
  loanId
  depositAmount
  rate
  timestamp
  emittedBy
  transaction
}

type FeeSharingTokensTransferred {
  id: ID!
  sender: Bytes!
  token: Bytes!
  amount: BigInt!
}

input FeeSharingTokensTransferred_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
}

enum FeeSharingTokensTransferred_orderBy {
  id
  sender
  token
  amount
}

type LendingHistoryItem {
  id: ID!
  lender: User!
  type: LendingHistoryType!
  lendingPool: LendingPool!

  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  amount: BigInt!
  loanTokenAmount: BigInt!
  transaction: Transaction!
  emittedBy: String!
  userLendingHistory: UserLendingHistory!
}

input LendingHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  lender: String
  lender_not: String
  lender_gt: String
  lender_lt: String
  lender_gte: String
  lender_lte: String
  lender_in: [String!]
  lender_not_in: [String!]
  lender_contains: String
  lender_not_contains: String
  lender_starts_with: String
  lender_not_starts_with: String
  lender_ends_with: String
  lender_not_ends_with: String
  type: LendingHistoryType
  type_not: LendingHistoryType
  type_in: [LendingHistoryType!]
  type_not_in: [LendingHistoryType!]
  lendingPool: String
  lendingPool_not: String
  lendingPool_gt: String
  lendingPool_lt: String
  lendingPool_gte: String
  lendingPool_lte: String
  lendingPool_in: [String!]
  lendingPool_not_in: [String!]
  lendingPool_contains: String
  lendingPool_not_contains: String
  lendingPool_starts_with: String
  lendingPool_not_starts_with: String
  lendingPool_ends_with: String
  lendingPool_not_ends_with: String
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_not_contains: String
  asset_starts_with: String
  asset_not_starts_with: String
  asset_ends_with: String
  asset_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  loanTokenAmount: BigInt
  loanTokenAmount_not: BigInt
  loanTokenAmount_gt: BigInt
  loanTokenAmount_lt: BigInt
  loanTokenAmount_gte: BigInt
  loanTokenAmount_lte: BigInt
  loanTokenAmount_in: [BigInt!]
  loanTokenAmount_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
  userLendingHistory: String
  userLendingHistory_not: String
  userLendingHistory_gt: String
  userLendingHistory_lt: String
  userLendingHistory_gte: String
  userLendingHistory_lte: String
  userLendingHistory_in: [String!]
  userLendingHistory_not_in: [String!]
  userLendingHistory_contains: String
  userLendingHistory_not_contains: String
  userLendingHistory_starts_with: String
  userLendingHistory_not_starts_with: String
  userLendingHistory_ends_with: String
  userLendingHistory_not_ends_with: String
}

enum LendingHistoryItem_orderBy {
  id
  lender
  type
  lendingPool
  asset
  amount
  loanTokenAmount
  transaction
  emittedBy
  userLendingHistory
}

enum LendingHistoryType {
  Lend
  UnLend
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users
can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool {
  """
  ID is the contract address of the iToken
  """
  id: ID!

  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
  poolTokenBalance: BigInt!
  assetBalance: BigInt!

  """
  Total asset volume lent over all time
  """
  totalAssetLent: BigInt!
}

input LendingPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  underlyingAsset: String
  underlyingAsset_not: String
  underlyingAsset_gt: String
  underlyingAsset_lt: String
  underlyingAsset_gte: String
  underlyingAsset_lte: String
  underlyingAsset_in: [String!]
  underlyingAsset_not_in: [String!]
  underlyingAsset_contains: String
  underlyingAsset_not_contains: String
  underlyingAsset_starts_with: String
  underlyingAsset_not_starts_with: String
  underlyingAsset_ends_with: String
  underlyingAsset_not_ends_with: String
  poolTokenBalance: BigInt
  poolTokenBalance_not: BigInt
  poolTokenBalance_gt: BigInt
  poolTokenBalance_lt: BigInt
  poolTokenBalance_gte: BigInt
  poolTokenBalance_lte: BigInt
  poolTokenBalance_in: [BigInt!]
  poolTokenBalance_not_in: [BigInt!]
  assetBalance: BigInt
  assetBalance_not: BigInt
  assetBalance_gt: BigInt
  assetBalance_lt: BigInt
  assetBalance_gte: BigInt
  assetBalance_lte: BigInt
  assetBalance_in: [BigInt!]
  assetBalance_not_in: [BigInt!]
  totalAssetLent: BigInt
  totalAssetLent_not: BigInt
  totalAssetLent_gt: BigInt
  totalAssetLent_lt: BigInt
  totalAssetLent_gte: BigInt
  totalAssetLent_lte: BigInt
  totalAssetLent_in: [BigInt!]
  totalAssetLent_not_in: [BigInt!]
}

enum LendingPool_orderBy {
  id
  underlyingAsset
  poolTokenBalance
  assetBalance
  totalAssetLent
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate {
  id: ID!
  user: User!
  liquidator: Bytes!
  loanId: Loan!
  lender: Bytes!
  loanToken: Bytes!
  collateralToken: Bytes!
  repayAmount: BigInt!
  collateralWithdrawAmount: BigInt!
  collateralToLoanRate: BigInt!
  currentMargin: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input Liquidate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  liquidator: Bytes
  liquidator_not: Bytes
  liquidator_in: [Bytes!]
  liquidator_not_in: [Bytes!]
  liquidator_contains: Bytes
  liquidator_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  lender: Bytes
  lender_not: Bytes
  lender_in: [Bytes!]
  lender_not_in: [Bytes!]
  lender_contains: Bytes
  lender_not_contains: Bytes
  loanToken: Bytes
  loanToken_not: Bytes
  loanToken_in: [Bytes!]
  loanToken_not_in: [Bytes!]
  loanToken_contains: Bytes
  loanToken_not_contains: Bytes
  collateralToken: Bytes
  collateralToken_not: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not_in: [Bytes!]
  collateralToken_contains: Bytes
  collateralToken_not_contains: Bytes
  repayAmount: BigInt
  repayAmount_not: BigInt
  repayAmount_gt: BigInt
  repayAmount_lt: BigInt
  repayAmount_gte: BigInt
  repayAmount_lte: BigInt
  repayAmount_in: [BigInt!]
  repayAmount_not_in: [BigInt!]
  collateralWithdrawAmount: BigInt
  collateralWithdrawAmount_not: BigInt
  collateralWithdrawAmount_gt: BigInt
  collateralWithdrawAmount_lt: BigInt
  collateralWithdrawAmount_gte: BigInt
  collateralWithdrawAmount_lte: BigInt
  collateralWithdrawAmount_in: [BigInt!]
  collateralWithdrawAmount_not_in: [BigInt!]
  collateralToLoanRate: BigInt
  collateralToLoanRate_not: BigInt
  collateralToLoanRate_gt: BigInt
  collateralToLoanRate_lt: BigInt
  collateralToLoanRate_gte: BigInt
  collateralToLoanRate_lte: BigInt
  collateralToLoanRate_in: [BigInt!]
  collateralToLoanRate_not_in: [BigInt!]
  currentMargin: BigInt
  currentMargin_not: BigInt
  currentMargin_gt: BigInt
  currentMargin_lt: BigInt
  currentMargin_gte: BigInt
  currentMargin_lte: BigInt
  currentMargin_in: [BigInt!]
  currentMargin_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum Liquidate_orderBy {
  id
  user
  liquidator
  loanId
  lender
  loanToken
  collateralToken
  repayAmount
  collateralWithdrawAmount
  collateralToLoanRate
  currentMargin
  timestamp
  emittedBy
  transaction
}

type LiquidityHistoryItem {
  """
  ID is transaction hash + log index
  """
  id: ID!
  user: User!
  userLiquidityHistory: UserLiquidityHistory!
  type: LiquidityHistoryType!
  provider: String!
  reserveToken: Token!
  amount: BigInt!
  newBalance: BigInt!
  newSupply: BigInt!
  timestamp: BigInt!
  liquidityPool: LiquidityPool!
  emittedBy: String!
  transaction: Transaction!
}

input LiquidityHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  userLiquidityHistory: String
  userLiquidityHistory_not: String
  userLiquidityHistory_gt: String
  userLiquidityHistory_lt: String
  userLiquidityHistory_gte: String
  userLiquidityHistory_lte: String
  userLiquidityHistory_in: [String!]
  userLiquidityHistory_not_in: [String!]
  userLiquidityHistory_contains: String
  userLiquidityHistory_not_contains: String
  userLiquidityHistory_starts_with: String
  userLiquidityHistory_not_starts_with: String
  userLiquidityHistory_ends_with: String
  userLiquidityHistory_not_ends_with: String
  type: LiquidityHistoryType
  type_not: LiquidityHistoryType
  type_in: [LiquidityHistoryType!]
  type_not_in: [LiquidityHistoryType!]
  provider: String
  provider_not: String
  provider_gt: String
  provider_lt: String
  provider_gte: String
  provider_lte: String
  provider_in: [String!]
  provider_not_in: [String!]
  provider_contains: String
  provider_not_contains: String
  provider_starts_with: String
  provider_not_starts_with: String
  provider_ends_with: String
  provider_not_ends_with: String
  reserveToken: String
  reserveToken_not: String
  reserveToken_gt: String
  reserveToken_lt: String
  reserveToken_gte: String
  reserveToken_lte: String
  reserveToken_in: [String!]
  reserveToken_not_in: [String!]
  reserveToken_contains: String
  reserveToken_not_contains: String
  reserveToken_starts_with: String
  reserveToken_not_starts_with: String
  reserveToken_ends_with: String
  reserveToken_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  newBalance: BigInt
  newBalance_not: BigInt
  newBalance_gt: BigInt
  newBalance_lt: BigInt
  newBalance_gte: BigInt
  newBalance_lte: BigInt
  newBalance_in: [BigInt!]
  newBalance_not_in: [BigInt!]
  newSupply: BigInt
  newSupply_not: BigInt
  newSupply_gt: BigInt
  newSupply_lt: BigInt
  newSupply_gte: BigInt
  newSupply_lte: BigInt
  newSupply_in: [BigInt!]
  newSupply_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
  emittedBy: String
  emittedBy_not: String
  emittedBy_gt: String
  emittedBy_lt: String
  emittedBy_gte: String
  emittedBy_lte: String
  emittedBy_in: [String!]
  emittedBy_not_in: [String!]
  emittedBy_contains: String
  emittedBy_not_contains: String
  emittedBy_starts_with: String
  emittedBy_not_starts_with: String
  emittedBy_ends_with: String
  emittedBy_not_ends_with: String
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum LiquidityHistoryItem_orderBy {
  id
  user
  userLiquidityHistory
  type
  provider
  reserveToken
  amount
  newBalance
  newSupply
  timestamp
  liquidityPool
  emittedBy
  transaction
}

enum LiquidityHistoryType {
  Added
  Removed
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool {
  """
  ID is the contract address of the Converter
  """
  id: ID!

  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken

  """
  The reserve assets of this AMM Pool. The are stored here like this so that
  they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  connectorTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]!
  poolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]!
  owner: String
  conversionFee: BigInt
  weight: BigInt

  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  maxConversionFee: BigInt
  lastResetBlockNumber: BigInt
  lastResetTimestamp: BigInt
  createdAtTimestamp: BigInt
  createdAtBlockNumber: BigInt
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
}

input LiquidityPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: Int
  type_not: Int
  type_gt: Int
  type_lt: Int
  type_gte: Int
  type_lte: Int
  type_in: [Int!]
  type_not_in: [Int!]
  version: Int
  version_not: Int
  version_gt: Int
  version_lt: Int
  version_gte: Int
  version_lte: Int
  version_in: [Int!]
  version_not_in: [Int!]
  smartToken: String
  smartToken_not: String
  smartToken_gt: String
  smartToken_lt: String
  smartToken_gte: String
  smartToken_lte: String
  smartToken_in: [String!]
  smartToken_not_in: [String!]
  smartToken_contains: String
  smartToken_not_contains: String
  smartToken_starts_with: String
  smartToken_not_starts_with: String
  smartToken_ends_with: String
  smartToken_not_ends_with: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_not_contains: String
  token0_starts_with: String
  token0_not_starts_with: String
  token0_ends_with: String
  token0_not_ends_with: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_not_contains: String
  token1_starts_with: String
  token1_not_starts_with: String
  token1_ends_with: String
  token1_not_ends_with: String
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_not_contains: String
  owner_starts_with: String
  owner_not_starts_with: String
  owner_ends_with: String
  owner_not_ends_with: String
  conversionFee: BigInt
  conversionFee_not: BigInt
  conversionFee_gt: BigInt
  conversionFee_lt: BigInt
  conversionFee_gte: BigInt
  conversionFee_lte: BigInt
  conversionFee_in: [BigInt!]
  conversionFee_not_in: [BigInt!]
  weight: BigInt
  weight_not: BigInt
  weight_gt: BigInt
  weight_lt: BigInt
  weight_gte: BigInt
  weight_lte: BigInt
  weight_in: [BigInt!]
  weight_not_in: [BigInt!]
  activated: Boolean
  activated_not: Boolean
  activated_in: [Boolean!]
  activated_not_in: [Boolean!]
  maxConversionFee: BigInt
  maxConversionFee_not: BigInt
  maxConversionFee_gt: BigInt
  maxConversionFee_lt: BigInt
  maxConversionFee_gte: BigInt
  maxConversionFee_lte: BigInt
  maxConversionFee_in: [BigInt!]
  maxConversionFee_not_in: [BigInt!]
  lastResetBlockNumber: BigInt
  lastResetBlockNumber_not: BigInt
  lastResetBlockNumber_gt: BigInt
  lastResetBlockNumber_lt: BigInt
  lastResetBlockNumber_gte: BigInt
  lastResetBlockNumber_lte: BigInt
  lastResetBlockNumber_in: [BigInt!]
  lastResetBlockNumber_not_in: [BigInt!]
  lastResetTimestamp: BigInt
  lastResetTimestamp_not: BigInt
  lastResetTimestamp_gt: BigInt
  lastResetTimestamp_lt: BigInt
  lastResetTimestamp_gte: BigInt
  lastResetTimestamp_lte: BigInt
  lastResetTimestamp_in: [BigInt!]
  lastResetTimestamp_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTransaction: String
  createdAtTransaction_not: String
  createdAtTransaction_gt: String
  createdAtTransaction_lt: String
  createdAtTransaction_gte: String
  createdAtTransaction_lte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_contains: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_not_ends_with: String
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
}

enum LiquidityPool_orderBy {
  id
  type
  version
  smartToken
  token0
  token1
  connectorTokens
  poolTokens
  owner
  conversionFee
  weight
  activated
  maxConversionFee
  lastResetBlockNumber
  lastResetTimestamp
  createdAtTimestamp
  createdAtBlockNumber
  createdAtTransaction
  currentConverterRegistry
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolAdded {
  id: ID!
  _liquidityPool: Bytes!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input LiquidityPoolAdded_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _liquidityPool: Bytes
  _liquidityPool_not: Bytes
  _liquidityPool_in: [Bytes!]
  _liquidityPool_not_in: [Bytes!]
  _liquidityPool_contains: Bytes
  _liquidityPool_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum LiquidityPoolAdded_orderBy {
  id
  _liquidityPool
  timestamp
  emittedBy
  transaction
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolRemoved {
  id: ID!
  _liquidityPool: Bytes!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input LiquidityPoolRemoved_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _liquidityPool: Bytes
  _liquidityPool_not: Bytes
  _liquidityPool_in: [Bytes!]
  _liquidityPool_not_in: [Bytes!]
  _liquidityPool_contains: Bytes
  _liquidityPool_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum LiquidityPoolRemoved_orderBy {
  id
  _liquidityPool
  timestamp
  emittedBy
  transaction
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and so
"""
type LiquidityPoolToken {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!

  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  volumeBought: BigDecimal!
  volumeSold: BigDecimal!
  totalVolume: BigDecimal!
}

input LiquidityPoolToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
  poolToken: String
  poolToken_not: String
  poolToken_gt: String
  poolToken_lt: String
  poolToken_gte: String
  poolToken_lte: String
  poolToken_in: [String!]
  poolToken_not_in: [String!]
  poolToken_contains: String
  poolToken_not_contains: String
  poolToken_starts_with: String
  poolToken_not_starts_with: String
  poolToken_ends_with: String
  poolToken_not_ends_with: String
  volumeBought: BigDecimal
  volumeBought_not: BigDecimal
  volumeBought_gt: BigDecimal
  volumeBought_lt: BigDecimal
  volumeBought_gte: BigDecimal
  volumeBought_lte: BigDecimal
  volumeBought_in: [BigDecimal!]
  volumeBought_not_in: [BigDecimal!]
  volumeSold: BigDecimal
  volumeSold_not: BigDecimal
  volumeSold_gt: BigDecimal
  volumeSold_lt: BigDecimal
  volumeSold_gte: BigDecimal
  volumeSold_lte: BigDecimal
  volumeSold_in: [BigDecimal!]
  volumeSold_not_in: [BigDecimal!]
  totalVolume: BigDecimal
  totalVolume_not: BigDecimal
  totalVolume_gt: BigDecimal
  totalVolume_lt: BigDecimal
  totalVolume_gte: BigDecimal
  totalVolume_lte: BigDecimal
  totalVolume_in: [BigDecimal!]
  totalVolume_not_in: [BigDecimal!]
}

enum LiquidityPoolToken_orderBy {
  id
  token
  liquidityPool
  poolToken
  volumeBought
  volumeSold
  totalVolume
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan {
  id: ID!
  loanToken: Token!
  collateralToken: Token!

  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  startTimestamp: BigInt!
  endTimestamp: BigInt

  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: BigDecimal!
  startBorrowedAmount: BigDecimal!
  maxBorrowedAmount: BigDecimal!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: BigDecimal!

  """
  Initial size of the position
  """
  startPositionSize: BigDecimal!

  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: BigDecimal!

  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: BigDecimal!

  """
  If a Liquidate, CloseWithSwap or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  user: User!
  trade(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]
  borrow(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter
  ): [Borrow!]
  closeWithSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    where: CloseWithSwap_filter
  ): [CloseWithSwap!]
  closewithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter
  ): [CloseWithDeposit!]
  liquidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter
  ): [Liquidate!]
  depositCollateral(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter
  ): [DepositCollateral!]

  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: BigDecimal!

  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: BigDecimal!

  """
  Average price per token from all loan open events
  """
  averageBuyPrice: BigDecimal!

  """
  Average price per token from all loan close events
  """
  averageSellPrice: BigDecimal!

  """
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: BigDecimal!
  realizedPnLPercent: BigDecimal!
}

input Loan_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  loanToken: String
  loanToken_not: String
  loanToken_gt: String
  loanToken_lt: String
  loanToken_gte: String
  loanToken_lte: String
  loanToken_in: [String!]
  loanToken_not_in: [String!]
  loanToken_contains: String
  loanToken_not_contains: String
  loanToken_starts_with: String
  loanToken_not_starts_with: String
  loanToken_ends_with: String
  loanToken_not_ends_with: String
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_not_contains: String
  collateralToken_starts_with: String
  collateralToken_not_starts_with: String
  collateralToken_ends_with: String
  collateralToken_not_ends_with: String
  type: LoanType
  type_not: LoanType
  type_in: [LoanType!]
  type_not_in: [LoanType!]
  startTimestamp: BigInt
  startTimestamp_not: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_lt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_not_in: [BigInt!]
  endTimestamp: BigInt
  endTimestamp_not: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_lt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_not_in: [BigInt!]
  borrowedAmount: BigDecimal
  borrowedAmount_not: BigDecimal
  borrowedAmount_gt: BigDecimal
  borrowedAmount_lt: BigDecimal
  borrowedAmount_gte: BigDecimal
  borrowedAmount_lte: BigDecimal
  borrowedAmount_in: [BigDecimal!]
  borrowedAmount_not_in: [BigDecimal!]
  startBorrowedAmount: BigDecimal
  startBorrowedAmount_not: BigDecimal
  startBorrowedAmount_gt: BigDecimal
  startBorrowedAmount_lt: BigDecimal
  startBorrowedAmount_gte: BigDecimal
  startBorrowedAmount_lte: BigDecimal
  startBorrowedAmount_in: [BigDecimal!]
  startBorrowedAmount_not_in: [BigDecimal!]
  maxBorrowedAmount: BigDecimal
  maxBorrowedAmount_not: BigDecimal
  maxBorrowedAmount_gt: BigDecimal
  maxBorrowedAmount_lt: BigDecimal
  maxBorrowedAmount_gte: BigDecimal
  maxBorrowedAmount_lte: BigDecimal
  maxBorrowedAmount_in: [BigDecimal!]
  maxBorrowedAmount_not_in: [BigDecimal!]
  positionSize: BigDecimal
  positionSize_not: BigDecimal
  positionSize_gt: BigDecimal
  positionSize_lt: BigDecimal
  positionSize_gte: BigDecimal
  positionSize_lte: BigDecimal
  positionSize_in: [BigDecimal!]
  positionSize_not_in: [BigDecimal!]
  startPositionSize: BigDecimal
  startPositionSize_not: BigDecimal
  startPositionSize_gt: BigDecimal
  startPositionSize_lt: BigDecimal
  startPositionSize_gte: BigDecimal
  startPositionSize_lte: BigDecimal
  startPositionSize_in: [BigDecimal!]
  startPositionSize_not_in: [BigDecimal!]
  maximumPositionSize: BigDecimal
  maximumPositionSize_not: BigDecimal
  maximumPositionSize_gt: BigDecimal
  maximumPositionSize_lt: BigDecimal
  maximumPositionSize_gte: BigDecimal
  maximumPositionSize_lte: BigDecimal
  maximumPositionSize_in: [BigDecimal!]
  maximumPositionSize_not_in: [BigDecimal!]
  startRate: BigDecimal
  startRate_not: BigDecimal
  startRate_gt: BigDecimal
  startRate_lt: BigDecimal
  startRate_gte: BigDecimal
  startRate_lte: BigDecimal
  startRate_in: [BigDecimal!]
  startRate_not_in: [BigDecimal!]
  isOpen: Boolean
  isOpen_not: Boolean
  isOpen_in: [Boolean!]
  isOpen_not_in: [Boolean!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalBought: BigDecimal
  totalBought_not: BigDecimal
  totalBought_gt: BigDecimal
  totalBought_lt: BigDecimal
  totalBought_gte: BigDecimal
  totalBought_lte: BigDecimal
  totalBought_in: [BigDecimal!]
  totalBought_not_in: [BigDecimal!]
  totalSold: BigDecimal
  totalSold_not: BigDecimal
  totalSold_gt: BigDecimal
  totalSold_lt: BigDecimal
  totalSold_gte: BigDecimal
  totalSold_lte: BigDecimal
  totalSold_in: [BigDecimal!]
  totalSold_not_in: [BigDecimal!]
  averageBuyPrice: BigDecimal
  averageBuyPrice_not: BigDecimal
  averageBuyPrice_gt: BigDecimal
  averageBuyPrice_lt: BigDecimal
  averageBuyPrice_gte: BigDecimal
  averageBuyPrice_lte: BigDecimal
  averageBuyPrice_in: [BigDecimal!]
  averageBuyPrice_not_in: [BigDecimal!]
  averageSellPrice: BigDecimal
  averageSellPrice_not: BigDecimal
  averageSellPrice_gt: BigDecimal
  averageSellPrice_lt: BigDecimal
  averageSellPrice_gte: BigDecimal
  averageSellPrice_lte: BigDecimal
  averageSellPrice_in: [BigDecimal!]
  averageSellPrice_not_in: [BigDecimal!]
  realizedPnL: BigDecimal
  realizedPnL_not: BigDecimal
  realizedPnL_gt: BigDecimal
  realizedPnL_lt: BigDecimal
  realizedPnL_gte: BigDecimal
  realizedPnL_lte: BigDecimal
  realizedPnL_in: [BigDecimal!]
  realizedPnL_not_in: [BigDecimal!]
  realizedPnLPercent: BigDecimal
  realizedPnLPercent_not: BigDecimal
  realizedPnLPercent_gt: BigDecimal
  realizedPnLPercent_lt: BigDecimal
  realizedPnLPercent_gte: BigDecimal
  realizedPnLPercent_lte: BigDecimal
  realizedPnLPercent_in: [BigDecimal!]
  realizedPnLPercent_not_in: [BigDecimal!]
}

enum Loan_orderBy {
  id
  loanToken
  collateralToken
  type
  startTimestamp
  endTimestamp
  borrowedAmount
  startBorrowedAmount
  maxBorrowedAmount
  positionSize
  startPositionSize
  maximumPositionSize
  startRate
  isOpen
  user
  trade
  borrow
  closeWithSwaps
  closewithDeposits
  liquidates
  depositCollateral
  totalBought
  totalSold
  averageBuyPrice
  averageSellPrice
  realizedPnL
  realizedPnLPercent
}

enum LoanType {
  Trade
  Borrow
}

type NewConverter {
  id: ID!
  _type: Int!
  _converter: Bytes!
  _owner: Bytes!
  timestamp: BigInt!
  transaction: Transaction!
}

input NewConverter_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _type: Int
  _type_not: Int
  _type_gt: Int
  _type_lt: Int
  _type_gte: Int
  _type_lte: Int
  _type_in: [Int!]
  _type_not_in: [Int!]
  _converter: Bytes
  _converter_not: Bytes
  _converter_in: [Bytes!]
  _converter_not_in: [Bytes!]
  _converter_contains: Bytes
  _converter_not_contains: Bytes
  _owner: Bytes
  _owner_not: Bytes
  _owner_in: [Bytes!]
  _owner_not_in: [Bytes!]
  _owner_contains: Bytes
  _owner_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum NewConverter_orderBy {
  id
  _type
  _converter
  _owner
  timestamp
  transaction
}

enum OrderDirection {
  asc
  desc
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee {
  id: ID!
  payer: Bytes!
  token: Bytes!
  loanId: Loan!
  amount: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input PayBorrowingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: Bytes
  payer_not: Bytes
  payer_in: [Bytes!]
  payer_not_in: [Bytes!]
  payer_contains: Bytes
  payer_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum PayBorrowingFee_orderBy {
  id
  payer
  token
  loanId
  amount
  timestamp
  emittedBy
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee {
  id: ID!
  payer: Bytes!
  token: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input PayLendingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: Bytes
  payer_not: Bytes
  payer_in: [Bytes!]
  payer_not_in: [Bytes!]
  payer_contains: Bytes
  payer_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum PayLendingFee_orderBy {
  id
  payer
  token
  amount
  timestamp
  emittedBy
  transaction
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee {
  id: ID!
  payer: Bytes!
  token: Bytes!
  loanId: Loan!
  amount: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input PayTradingFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  payer: Bytes
  payer_not: Bytes
  payer_in: [Bytes!]
  payer_not_in: [Bytes!]
  payer_contains: Bytes
  payer_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum PayTradingFee_orderBy {
  id
  payer
  token
  loanId
  amount
  timestamp
  emittedBy
  transaction
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2
pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  converters(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]
  underlyingAssets(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    where: TokenPoolToken_filter
  ): [TokenPoolToken!]
}

input PoolToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
}

enum PoolToken_orderBy {
  id
  name
  symbol
  decimals
  converters
  underlyingAssets
}

type Proposal {
  id: ID!
  created: Transaction!
  canceled: Transaction
  executed: Transaction
  queued: Transaction
  votesFor: BigInt!
  votesAgainst: BigInt!
  countVotersFor: BigInt!
  countVotersAgainst: BigInt!
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter
  ): [VoteCast!]
  proposalId: BigInt!
  proposer: Bytes!
  targets: [String!]!
  values: [BigInt!]!
  signatures: [String!]!
  startBlock: BigInt!
  endBlock: BigInt!
  description: String!
  timestamp: BigInt!
  emittedBy: Bytes!
}

input Proposal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  created: String
  created_not: String
  created_gt: String
  created_lt: String
  created_gte: String
  created_lte: String
  created_in: [String!]
  created_not_in: [String!]
  created_contains: String
  created_not_contains: String
  created_starts_with: String
  created_not_starts_with: String
  created_ends_with: String
  created_not_ends_with: String
  canceled: String
  canceled_not: String
  canceled_gt: String
  canceled_lt: String
  canceled_gte: String
  canceled_lte: String
  canceled_in: [String!]
  canceled_not_in: [String!]
  canceled_contains: String
  canceled_not_contains: String
  canceled_starts_with: String
  canceled_not_starts_with: String
  canceled_ends_with: String
  canceled_not_ends_with: String
  executed: String
  executed_not: String
  executed_gt: String
  executed_lt: String
  executed_gte: String
  executed_lte: String
  executed_in: [String!]
  executed_not_in: [String!]
  executed_contains: String
  executed_not_contains: String
  executed_starts_with: String
  executed_not_starts_with: String
  executed_ends_with: String
  executed_not_ends_with: String
  queued: String
  queued_not: String
  queued_gt: String
  queued_lt: String
  queued_gte: String
  queued_lte: String
  queued_in: [String!]
  queued_not_in: [String!]
  queued_contains: String
  queued_not_contains: String
  queued_starts_with: String
  queued_not_starts_with: String
  queued_ends_with: String
  queued_not_ends_with: String
  votesFor: BigInt
  votesFor_not: BigInt
  votesFor_gt: BigInt
  votesFor_lt: BigInt
  votesFor_gte: BigInt
  votesFor_lte: BigInt
  votesFor_in: [BigInt!]
  votesFor_not_in: [BigInt!]
  votesAgainst: BigInt
  votesAgainst_not: BigInt
  votesAgainst_gt: BigInt
  votesAgainst_lt: BigInt
  votesAgainst_gte: BigInt
  votesAgainst_lte: BigInt
  votesAgainst_in: [BigInt!]
  votesAgainst_not_in: [BigInt!]
  countVotersFor: BigInt
  countVotersFor_not: BigInt
  countVotersFor_gt: BigInt
  countVotersFor_lt: BigInt
  countVotersFor_gte: BigInt
  countVotersFor_lte: BigInt
  countVotersFor_in: [BigInt!]
  countVotersFor_not_in: [BigInt!]
  countVotersAgainst: BigInt
  countVotersAgainst_not: BigInt
  countVotersAgainst_gt: BigInt
  countVotersAgainst_lt: BigInt
  countVotersAgainst_gte: BigInt
  countVotersAgainst_lte: BigInt
  countVotersAgainst_in: [BigInt!]
  countVotersAgainst_not_in: [BigInt!]
  proposalId: BigInt
  proposalId_not: BigInt
  proposalId_gt: BigInt
  proposalId_lt: BigInt
  proposalId_gte: BigInt
  proposalId_lte: BigInt
  proposalId_in: [BigInt!]
  proposalId_not_in: [BigInt!]
  proposer: Bytes
  proposer_not: Bytes
  proposer_in: [Bytes!]
  proposer_not_in: [Bytes!]
  proposer_contains: Bytes
  proposer_not_contains: Bytes
  targets: [String!]
  targets_not: [String!]
  targets_contains: [String!]
  targets_not_contains: [String!]
  values: [BigInt!]
  values_not: [BigInt!]
  values_contains: [BigInt!]
  values_not_contains: [BigInt!]
  signatures: [String!]
  signatures_not: [String!]
  signatures_contains: [String!]
  signatures_not_contains: [String!]
  startBlock: BigInt
  startBlock_not: BigInt
  startBlock_gt: BigInt
  startBlock_lt: BigInt
  startBlock_gte: BigInt
  startBlock_lte: BigInt
  startBlock_in: [BigInt!]
  startBlock_not_in: [BigInt!]
  endBlock: BigInt
  endBlock_not: BigInt
  endBlock_gt: BigInt
  endBlock_lt: BigInt
  endBlock_gte: BigInt
  endBlock_lte: BigInt
  endBlock_in: [BigInt!]
  endBlock_not_in: [BigInt!]
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
}

enum Proposal_orderBy {
  id
  created
  canceled
  executed
  queued
  votesFor
  votesAgainst
  countVotersFor
  countVotersAgainst
  votes
  proposalId
  proposer
  targets
  values
  signatures
  startBlock
  endBlock
  description
  timestamp
  emittedBy
}

"""
This entity will have only one instance and will be used to store protocol-wide
data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!

  """
  An array of all tokens in the protocol
  """
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
  ): [Token!]!
  usdStablecoin: Token!
  btcUsdPrice: BigDecimal!

  """
  Total number of users of the protocol. This number is incremented each time a
  user initiates a transaction with the Protocol.
  Currently this is incremented by specific user actions, but could be incremented on a per Transaction basis.
  """
  totalUsers: BigInt!

  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: BigDecimal!

  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: BigDecimal!

  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: BigDecimal!

  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: BigDecimal!

  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: BigDecimal!

  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: BigDecimal!

  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in
  usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: BigDecimal!

  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: BigDecimal!

  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: BigDecimal!

  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: BigDecimal!

  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: BigDecimal!

  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: BigDecimal!

  """
  Total of collateral property in Trade event (in usd). This may be changed to
  borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: BigDecimal!

  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: BigDecimal!

  """
  This is SOV staked by users (not vesting contracts). It is incremented when
  users stake tokens, and decremented when users withdraw tokens from the
  staking contract
  """
  totalVoluntarilyStakedSov: BigInt!

  """
  This is SOV staked by vesting contracts. It in incremented when the contracts
  stake the tokens, and decremented when users claim their unlocked tokens
  """
  totalStakedByVestingSov: BigInt!

  """
  NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types
  (AMM Swaps, Margin Trades, CloseWithSwap etc etc)
  """
  totalTransactedVolumeUsd: BigInt!
}

input ProtocolStats_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  tokens: [String!]
  tokens_not: [String!]
  tokens_contains: [String!]
  tokens_not_contains: [String!]
  usdStablecoin: String
  usdStablecoin_not: String
  usdStablecoin_gt: String
  usdStablecoin_lt: String
  usdStablecoin_gte: String
  usdStablecoin_lte: String
  usdStablecoin_in: [String!]
  usdStablecoin_not_in: [String!]
  usdStablecoin_contains: String
  usdStablecoin_not_contains: String
  usdStablecoin_starts_with: String
  usdStablecoin_not_starts_with: String
  usdStablecoin_ends_with: String
  usdStablecoin_not_ends_with: String
  btcUsdPrice: BigDecimal
  btcUsdPrice_not: BigDecimal
  btcUsdPrice_gt: BigDecimal
  btcUsdPrice_lt: BigDecimal
  btcUsdPrice_gte: BigDecimal
  btcUsdPrice_lte: BigDecimal
  btcUsdPrice_in: [BigDecimal!]
  btcUsdPrice_not_in: [BigDecimal!]
  totalUsers: BigInt
  totalUsers_not: BigInt
  totalUsers_gt: BigInt
  totalUsers_lt: BigInt
  totalUsers_gte: BigInt
  totalUsers_lte: BigInt
  totalUsers_in: [BigInt!]
  totalUsers_not_in: [BigInt!]
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
  totalVoluntarilyStakedSov: BigInt
  totalVoluntarilyStakedSov_not: BigInt
  totalVoluntarilyStakedSov_gt: BigInt
  totalVoluntarilyStakedSov_lt: BigInt
  totalVoluntarilyStakedSov_gte: BigInt
  totalVoluntarilyStakedSov_lte: BigInt
  totalVoluntarilyStakedSov_in: [BigInt!]
  totalVoluntarilyStakedSov_not_in: [BigInt!]
  totalStakedByVestingSov: BigInt
  totalStakedByVestingSov_not: BigInt
  totalStakedByVestingSov_gt: BigInt
  totalStakedByVestingSov_lt: BigInt
  totalStakedByVestingSov_gte: BigInt
  totalStakedByVestingSov_lte: BigInt
  totalStakedByVestingSov_in: [BigInt!]
  totalStakedByVestingSov_not_in: [BigInt!]
  totalTransactedVolumeUsd: BigInt
  totalTransactedVolumeUsd_not: BigInt
  totalTransactedVolumeUsd_gt: BigInt
  totalTransactedVolumeUsd_lt: BigInt
  totalTransactedVolumeUsd_gte: BigInt
  totalTransactedVolumeUsd_lte: BigInt
  totalTransactedVolumeUsd_in: [BigInt!]
  totalTransactedVolumeUsd_not_in: [BigInt!]
}

enum ProtocolStats_orderBy {
  id
  tokens
  usdStablecoin
  btcUsdPrice
  totalUsers
  totalMarginTradeVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLiquidateVolumeUsd
  totalAmmVolumeUsd
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalTradingFeesUsd
  totalLendingFeesUsd
  totalBorrowingFeesUsd
  totalLendVolumeUsd
  totalUnlendVolumeUsd
  totalBorrowVolumeUsd
  totalCloseWithDepositVolumeUsd
  totalVoluntarilyStakedSov
  totalStakedByVestingSov
  totalTransactedVolumeUsd
}

type Query {
  converterRegistry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  converterRegistries(
    skip: Int = 0
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    where: ConverterRegistry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConverterRegistry!]!
  smartToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    where: SmartToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartToken!]!
  tokenSmartToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSmartToken!]!
  poolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    where: PoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolToken!]!
  swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  conversion(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    skip: Int = 0
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    where: Conversion_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Conversion!]!
  liquidityPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolToken!]!
  tokenPoolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPoolToken
  tokenPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    where: TokenPoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenPoolToken!]!
  newConverter(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewConverter
  newConverters(
    skip: Int = 0
    first: Int = 100
    orderBy: NewConverter_orderBy
    orderDirection: OrderDirection
    where: NewConverter_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewConverter!]!
  liquidityPoolAdded(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolAdded
  liquidityPoolAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolAdded_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolAdded_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolAdded!]!
  liquidityPoolRemoved(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolRemoved
  liquidityPoolRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolRemoved_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolRemoved_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolRemoved!]!
  smartTokenAdded(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenAdded
  smartTokenAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartTokenAdded_orderBy
    orderDirection: OrderDirection
    where: SmartTokenAdded_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartTokenAdded!]!
  smartTokenRemoved(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenRemoved
  smartTokenRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartTokenRemoved_orderBy
    orderDirection: OrderDirection
    where: SmartTokenRemoved_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartTokenRemoved!]!
  candleStick(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    where: CandleStick_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStick!]!
  proposal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  voteCast(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteCast!]!
  lendingPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    where: LendingPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingPool!]!
  userLendingHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLendingHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLendingHistory!]!
  lendingHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingHistoryItem!]!
  userLiquidityHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userLiquidityHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLiquidityHistory!]!
  liquidityHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityHistoryItem!]!
  loan(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    skip: Int = 0
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    where: Loan_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Loan!]!
  borrow(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Borrow!]!
  closeWithDeposit(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithDeposit!]!
  closeWithSwap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    where: CloseWithSwap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithSwap!]!
  depositCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositCollateral!]!
  liquidate(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidate!]!
  payBorrowingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    where: PayBorrowingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayBorrowingFee!]!
  payLendingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    where: PayLendingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayLendingFee!]!
  payTradingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    where: PayTradingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayTradingFee!]!
  trade(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  protocolStats(
    skip: Int = 0
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    where: ProtocolStats_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProtocolStats!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  userRewardsEarnedHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userRewardsEarnedHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserRewardsEarnedHistory!]!
  rewardsEarnedHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardsEarnedHistoryItem!]!
  tokensStaked(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    where: TokensStaked_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensStaked!]!
  userStakeHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userStakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserStakeHistory!]!
  stakeHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistoryItem!]!
  feeSharingTokensTransferred(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    where: FeeSharingTokensTransferred_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeSharingTokensTransferred!]!
  user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  userTotal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    skip: Int = 0
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    where: UserTotal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserTotal!]!
  vestingContract(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingContract!]!
  vestingHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingHistoryItem!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

enum RewardsEarnedAction {
  StakingRewardWithdrawn
  EarnReward
  RewardClaimed
  RewardSovStaked
}

type RewardsEarnedHistoryItem {
  id: ID!
  action: RewardsEarnedAction!
  user: UserRewardsEarnedHistory!
  token: Token
  amount: BigInt!
  timestamp: BigInt!
  transaction: Transaction!
}

input RewardsEarnedHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  action: RewardsEarnedAction
  action_not: RewardsEarnedAction
  action_in: [RewardsEarnedAction!]
  action_not_in: [RewardsEarnedAction!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum RewardsEarnedHistoryItem_orderBy {
  id
  action
  user
  token
  amount
  timestamp
  transaction
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2
pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken {
  """
  ID is smart token address
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int

  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String
  transfersEnabled: Boolean

  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool!

  """
  connectorTokens are the entity that holds the many-to-many relationship
  between the underlying token asset and the smart token
  """
  connectorTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]
  owner: Bytes!
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: BigInt
  addedToRegistryTransactionHash: Bytes
}

input SmartToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  version: Int
  version_not: Int
  version_gt: Int
  version_lt: Int
  version_gte: Int
  version_lte: Int
  version_in: [Int!]
  version_not_in: [Int!]
  smartTokenType: String
  smartTokenType_not: String
  smartTokenType_gt: String
  smartTokenType_lt: String
  smartTokenType_gte: String
  smartTokenType_lte: String
  smartTokenType_in: [String!]
  smartTokenType_not_in: [String!]
  smartTokenType_contains: String
  smartTokenType_not_contains: String
  smartTokenType_starts_with: String
  smartTokenType_not_starts_with: String
  smartTokenType_ends_with: String
  smartTokenType_not_ends_with: String
  transfersEnabled: Boolean
  transfersEnabled_not: Boolean
  transfersEnabled_in: [Boolean!]
  transfersEnabled_not_in: [Boolean!]
  owner: Bytes
  owner_not: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
  addedToRegistryBlockNumber: BigInt
  addedToRegistryBlockNumber_not: BigInt
  addedToRegistryBlockNumber_gt: BigInt
  addedToRegistryBlockNumber_lt: BigInt
  addedToRegistryBlockNumber_gte: BigInt
  addedToRegistryBlockNumber_lte: BigInt
  addedToRegistryBlockNumber_in: [BigInt!]
  addedToRegistryBlockNumber_not_in: [BigInt!]
  addedToRegistryTransactionHash: Bytes
  addedToRegistryTransactionHash_not: Bytes
  addedToRegistryTransactionHash_in: [Bytes!]
  addedToRegistryTransactionHash_not_in: [Bytes!]
  addedToRegistryTransactionHash_contains: Bytes
  addedToRegistryTransactionHash_not_contains: Bytes
}

enum SmartToken_orderBy {
  id
  name
  symbol
  decimals
  version
  smartTokenType
  transfersEnabled
  liquidityPool
  connectorTokens
  owner
  currentConverterRegistry
  addedToRegistryBlockNumber
  addedToRegistryTransactionHash
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenAdded {
  id: ID!
  _smartToken: Bytes!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input SmartTokenAdded_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _smartToken: Bytes
  _smartToken_not: Bytes
  _smartToken_in: [Bytes!]
  _smartToken_not_in: [Bytes!]
  _smartToken_contains: Bytes
  _smartToken_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum SmartTokenAdded_orderBy {
  id
  _smartToken
  timestamp
  emittedBy
  transaction
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenRemoved {
  id: ID!
  _smartToken: Bytes!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input SmartTokenRemoved_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  _smartToken: Bytes
  _smartToken_not: Bytes
  _smartToken_in: [Bytes!]
  _smartToken_not_in: [Bytes!]
  _smartToken_contains: Bytes
  _smartToken_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum SmartTokenRemoved_orderBy {
  id
  _smartToken
  timestamp
  emittedBy
  transaction
}

enum StakeHistoryAction {
  Stake
  IncreaseStake
  ExtendStake
  Delegate
  Unstake
  WithdrawStaked
  FeeWithdrawn
}

type StakeHistoryItem {
  id: ID!
  user: UserStakeHistory!
  action: StakeHistoryAction!
  timestamp: BigInt!
  transaction: Transaction!
  amount: BigInt
  lockedUntil: BigInt
}

input StakeHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  action: StakeHistoryAction
  action_not: StakeHistoryAction
  action_in: [StakeHistoryAction!]
  action_not_in: [StakeHistoryAction!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lockedUntil: BigInt
  lockedUntil_not: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_lt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_not_in: [BigInt!]
}

enum StakeHistoryItem_orderBy {
  id
  user
  action
  timestamp
  transaction
  amount
  lockedUntil
}

type Subscription {
  converterRegistry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConverterRegistry
  converterRegistries(
    skip: Int = 0
    first: Int = 100
    orderBy: ConverterRegistry_orderBy
    orderDirection: OrderDirection
    where: ConverterRegistry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConverterRegistry!]!
  smartToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartToken
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartToken_orderBy
    orderDirection: OrderDirection
    where: SmartToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartToken!]!
  tokenSmartToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSmartToken
  tokenSmartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSmartToken!]!
  poolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    where: PoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolToken!]!
  swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  conversion(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Conversion
  conversions(
    skip: Int = 0
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    where: Conversion_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Conversion!]!
  liquidityPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPool
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPool_orderBy
    orderDirection: OrderDirection
    where: LiquidityPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPool!]!
  liquidityPoolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolToken
  liquidityPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolToken!]!
  tokenPoolToken(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPoolToken
  tokenPoolTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPoolToken_orderBy
    orderDirection: OrderDirection
    where: TokenPoolToken_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenPoolToken!]!
  newConverter(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewConverter
  newConverters(
    skip: Int = 0
    first: Int = 100
    orderBy: NewConverter_orderBy
    orderDirection: OrderDirection
    where: NewConverter_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewConverter!]!
  liquidityPoolAdded(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolAdded
  liquidityPoolAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolAdded_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolAdded_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolAdded!]!
  liquidityPoolRemoved(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPoolRemoved
  liquidityPoolRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolRemoved_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolRemoved_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityPoolRemoved!]!
  smartTokenAdded(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenAdded
  smartTokenAddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartTokenAdded_orderBy
    orderDirection: OrderDirection
    where: SmartTokenAdded_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartTokenAdded!]!
  smartTokenRemoved(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SmartTokenRemoved
  smartTokenRemoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: SmartTokenRemoved_orderBy
    orderDirection: OrderDirection
    where: SmartTokenRemoved_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SmartTokenRemoved!]!
  candleStick(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CandleStick
  candleSticks(
    skip: Int = 0
    first: Int = 100
    orderBy: CandleStick_orderBy
    orderDirection: OrderDirection
    where: CandleStick_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CandleStick!]!
  proposal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  voteCast(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteCast
  voteCasts(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteCast!]!
  lendingPool(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingPool
  lendingPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingPool_orderBy
    orderDirection: OrderDirection
    where: LendingPool_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingPool!]!
  userLendingHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLendingHistory
  userLendingHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLendingHistory!]!
  lendingHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LendingHistoryItem
  lendingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LendingHistoryItem!]!
  userLiquidityHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserLiquidityHistory
  userLiquidityHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserLiquidityHistory!]!
  liquidityHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityHistoryItem
  liquidityHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LiquidityHistoryItem!]!
  loan(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Loan
  loans(
    skip: Int = 0
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    where: Loan_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Loan!]!
  borrow(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Borrow
  borrows(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Borrow!]!
  closeWithDeposit(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithDeposit
  closeWithDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithDeposit_orderBy
    orderDirection: OrderDirection
    where: CloseWithDeposit_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithDeposit!]!
  closeWithSwap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CloseWithSwap
  closeWithSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: CloseWithSwap_orderBy
    orderDirection: OrderDirection
    where: CloseWithSwap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CloseWithSwap!]!
  depositCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositCollateral
  depositCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositCollateral_orderBy
    orderDirection: OrderDirection
    where: DepositCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositCollateral!]!
  liquidate(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidate
  liquidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Liquidate!]!
  payBorrowingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayBorrowingFee
  payBorrowingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayBorrowingFee_orderBy
    orderDirection: OrderDirection
    where: PayBorrowingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayBorrowingFee!]!
  payLendingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayLendingFee
  payLendingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayLendingFee_orderBy
    orderDirection: OrderDirection
    where: PayLendingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayLendingFee!]!
  payTradingFee(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PayTradingFee
  payTradingFees(
    skip: Int = 0
    first: Int = 100
    orderBy: PayTradingFee_orderBy
    orderDirection: OrderDirection
    where: PayTradingFee_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PayTradingFee!]!
  trade(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trade
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trade!]!
  protocolStats(
    skip: Int = 0
    first: Int = 100
    orderBy: ProtocolStats_orderBy
    orderDirection: OrderDirection
    where: ProtocolStats_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProtocolStats!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  userRewardsEarnedHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserRewardsEarnedHistory
  userRewardsEarnedHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserRewardsEarnedHistory!]!
  rewardsEarnedHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardsEarnedHistoryItem
  rewardsEarnedHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardsEarnedHistoryItem!]!
  tokensStaked(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensStaked
  tokensStakeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensStaked_orderBy
    orderDirection: OrderDirection
    where: TokensStaked_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensStaked!]!
  userStakeHistory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserStakeHistory
  userStakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserStakeHistory!]!
  stakeHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistoryItem
  stakeHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistoryItem!]!
  feeSharingTokensTransferred(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FeeSharingTokensTransferred
  feeSharingTokensTransferreds(
    skip: Int = 0
    first: Int = 100
    orderBy: FeeSharingTokensTransferred_orderBy
    orderDirection: OrderDirection
    where: FeeSharingTokensTransferred_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FeeSharingTokensTransferred!]!
  user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  userTotal(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserTotal
  userTotals(
    skip: Int = 0
    first: Int = 100
    orderBy: UserTotal_orderBy
    orderDirection: OrderDirection
    where: UserTotal_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserTotal!]!
  vestingContract(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingContract
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingContract!]!
  vestingHistoryItem(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VestingHistoryItem
  vestingHistoryItems(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VestingHistoryItem!]!

  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events
through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions
are aggregated here.
"""
type Swap {
  """
  Transaction hash of this swap
  """
  id: ID!

  """
  The AMM Conversion events involved in this swap
  """
  conversions(
    skip: Int = 0
    first: Int = 100
    orderBy: Conversion_orderBy
    orderDirection: OrderDirection
    where: Conversion_filter
  ): [Conversion!]

  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  fromToken: Token!
  toToken: Token!
  fromAmount: BigDecimal!
  toAmount: BigDecimal!

  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: BigDecimal!

  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null
  """
  user: User
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  timestamp: BigInt!
  transaction: Transaction!
}

input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  numConversions: Int
  numConversions_not: Int
  numConversions_gt: Int
  numConversions_lt: Int
  numConversions_gte: Int
  numConversions_lte: Int
  numConversions_in: [Int!]
  numConversions_not_in: [Int!]
  fromToken: String
  fromToken_not: String
  fromToken_gt: String
  fromToken_lt: String
  fromToken_gte: String
  fromToken_lte: String
  fromToken_in: [String!]
  fromToken_not_in: [String!]
  fromToken_contains: String
  fromToken_not_contains: String
  fromToken_starts_with: String
  fromToken_not_starts_with: String
  fromToken_ends_with: String
  fromToken_not_ends_with: String
  toToken: String
  toToken_not: String
  toToken_gt: String
  toToken_lt: String
  toToken_gte: String
  toToken_lte: String
  toToken_in: [String!]
  toToken_not_in: [String!]
  toToken_contains: String
  toToken_not_contains: String
  toToken_starts_with: String
  toToken_not_starts_with: String
  toToken_ends_with: String
  toToken_not_ends_with: String
  fromAmount: BigDecimal
  fromAmount_not: BigDecimal
  fromAmount_gt: BigDecimal
  fromAmount_lt: BigDecimal
  fromAmount_gte: BigDecimal
  fromAmount_lte: BigDecimal
  fromAmount_in: [BigDecimal!]
  fromAmount_not_in: [BigDecimal!]
  toAmount: BigDecimal
  toAmount_not: BigDecimal
  toAmount_gt: BigDecimal
  toAmount_lt: BigDecimal
  toAmount_gte: BigDecimal
  toAmount_lte: BigDecimal
  toAmount_in: [BigDecimal!]
  toAmount_not_in: [BigDecimal!]
  rate: BigDecimal
  rate_not: BigDecimal
  rate_gt: BigDecimal
  rate_lt: BigDecimal
  rate_gte: BigDecimal
  rate_lte: BigDecimal
  rate_in: [BigDecimal!]
  rate_not_in: [BigDecimal!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  isMarginTrade: Boolean
  isMarginTrade_not: Boolean
  isMarginTrade_in: [Boolean!]
  isMarginTrade_not_in: [Boolean!]
  isBorrow: Boolean
  isBorrow_not: Boolean
  isBorrow_in: [Boolean!]
  isBorrow_not_in: [Boolean!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum Swap_orderBy {
  id
  conversions
  numConversions
  fromToken
  toToken
  fromAmount
  toAmount
  rate
  user
  isMarginTrade
  isBorrow
  timestamp
  transaction
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token {
  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int

  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityPoolToken_orderBy
    orderDirection: OrderDirection
    where: LiquidityPoolToken_filter
  ): [LiquidityPoolToken!]

  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSmartToken_orderBy
    orderDirection: OrderDirection
    where: TokenSmartToken_filter
  ): [TokenSmartToken!]

  """
  previous BTC price used for candleSticks
  """
  prevPriceBtc: BigDecimal!
  lastPriceBtc: BigDecimal!

  """
  previous BTC price used for candleSticks
  """
  prevPriceUsd: BigDecimal!
  lastPriceUsd: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: BigDecimal!

  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: BigDecimal!
  currentConverterRegistry: ConverterRegistry

  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean

  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  version: Int
  version_not: Int
  version_gt: Int
  version_lt: Int
  version_gte: Int
  version_lte: Int
  version_in: [Int!]
  version_not_in: [Int!]
  prevPriceBtc: BigDecimal
  prevPriceBtc_not: BigDecimal
  prevPriceBtc_gt: BigDecimal
  prevPriceBtc_lt: BigDecimal
  prevPriceBtc_gte: BigDecimal
  prevPriceBtc_lte: BigDecimal
  prevPriceBtc_in: [BigDecimal!]
  prevPriceBtc_not_in: [BigDecimal!]
  lastPriceBtc: BigDecimal
  lastPriceBtc_not: BigDecimal
  lastPriceBtc_gt: BigDecimal
  lastPriceBtc_lt: BigDecimal
  lastPriceBtc_gte: BigDecimal
  lastPriceBtc_lte: BigDecimal
  lastPriceBtc_in: [BigDecimal!]
  lastPriceBtc_not_in: [BigDecimal!]
  prevPriceUsd: BigDecimal
  prevPriceUsd_not: BigDecimal
  prevPriceUsd_gt: BigDecimal
  prevPriceUsd_lt: BigDecimal
  prevPriceUsd_gte: BigDecimal
  prevPriceUsd_lte: BigDecimal
  prevPriceUsd_in: [BigDecimal!]
  prevPriceUsd_not_in: [BigDecimal!]
  lastPriceUsd: BigDecimal
  lastPriceUsd_not: BigDecimal
  lastPriceUsd_gt: BigDecimal
  lastPriceUsd_lt: BigDecimal
  lastPriceUsd_gte: BigDecimal
  lastPriceUsd_lte: BigDecimal
  lastPriceUsd_in: [BigDecimal!]
  lastPriceUsd_not_in: [BigDecimal!]
  btcVolume: BigDecimal
  btcVolume_not: BigDecimal
  btcVolume_gt: BigDecimal
  btcVolume_lt: BigDecimal
  btcVolume_gte: BigDecimal
  btcVolume_lte: BigDecimal
  btcVolume_in: [BigDecimal!]
  btcVolume_not_in: [BigDecimal!]
  usdVolume: BigDecimal
  usdVolume_not: BigDecimal
  usdVolume_gt: BigDecimal
  usdVolume_lt: BigDecimal
  usdVolume_gte: BigDecimal
  usdVolume_lte: BigDecimal
  usdVolume_in: [BigDecimal!]
  usdVolume_not_in: [BigDecimal!]
  tokenVolume: BigDecimal
  tokenVolume_not: BigDecimal
  tokenVolume_gt: BigDecimal
  tokenVolume_lt: BigDecimal
  tokenVolume_gte: BigDecimal
  tokenVolume_lte: BigDecimal
  tokenVolume_in: [BigDecimal!]
  tokenVolume_not_in: [BigDecimal!]
  currentConverterRegistry: String
  currentConverterRegistry_not: String
  currentConverterRegistry_gt: String
  currentConverterRegistry_lt: String
  currentConverterRegistry_gte: String
  currentConverterRegistry_lte: String
  currentConverterRegistry_in: [String!]
  currentConverterRegistry_not_in: [String!]
  currentConverterRegistry_contains: String
  currentConverterRegistry_not_contains: String
  currentConverterRegistry_starts_with: String
  currentConverterRegistry_not_starts_with: String
  currentConverterRegistry_ends_with: String
  currentConverterRegistry_not_ends_with: String
  hasBtcPool: Boolean
  hasBtcPool_not: Boolean
  hasBtcPool_in: [Boolean!]
  hasBtcPool_not_in: [Boolean!]
  hasStablecoinPool: Boolean
  hasStablecoinPool_not: Boolean
  hasStablecoinPool_in: [Boolean!]
  hasStablecoinPool_not_in: [Boolean!]
}

enum Token_orderBy {
  id
  name
  symbol
  decimals
  version
  liquidityPools
  smartTokens
  prevPriceBtc
  lastPriceBtc
  prevPriceUsd
  lastPriceUsd
  btcVolume
  usdVolume
  tokenVolume
  currentConverterRegistry
  hasBtcPool
  hasStablecoinPool
}

"""
The entity stores the many-to-many relationship between underlying tokens and pool tokens
"""
type TokenPoolToken {
  """
  ID is token address + poolToken address
  """
  id: ID!
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

input TokenPoolToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  poolToken: String
  poolToken_not: String
  poolToken_gt: String
  poolToken_lt: String
  poolToken_gte: String
  poolToken_lte: String
  poolToken_in: [String!]
  poolToken_not_in: [String!]
  poolToken_contains: String
  poolToken_not_contains: String
  poolToken_starts_with: String
  poolToken_not_starts_with: String
  poolToken_ends_with: String
  poolToken_not_ends_with: String
  liquidityPool: String
  liquidityPool_not: String
  liquidityPool_gt: String
  liquidityPool_lt: String
  liquidityPool_gte: String
  liquidityPool_lte: String
  liquidityPool_in: [String!]
  liquidityPool_not_in: [String!]
  liquidityPool_contains: String
  liquidityPool_not_contains: String
  liquidityPool_starts_with: String
  liquidityPool_not_starts_with: String
  liquidityPool_ends_with: String
  liquidityPool_not_ends_with: String
}

enum TokenPoolToken_orderBy {
  id
  token
  poolToken
  liquidityPool
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken {
  """
  ID is token address + smart token address
  """
  id: ID!

  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

input TokenSmartToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  smartToken: String
  smartToken_not: String
  smartToken_gt: String
  smartToken_lt: String
  smartToken_gte: String
  smartToken_lte: String
  smartToken_in: [String!]
  smartToken_not_in: [String!]
  smartToken_contains: String
  smartToken_not_contains: String
  smartToken_starts_with: String
  smartToken_not_starts_with: String
  smartToken_ends_with: String
  smartToken_not_ends_with: String
}

enum TokenSmartToken_orderBy {
  id
  token
  smartToken
}

type TokensStaked {
  id: ID!
  user: User
  staker: Bytes!
  amount: BigInt!
  lockedUntil: BigInt!
  totalStaked: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
  isUserStaked: Boolean!
}

input TokensStaked_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  staker: Bytes
  staker_not: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lockedUntil: BigInt
  lockedUntil_not: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_lt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_not_in: [BigInt!]
  totalStaked: BigInt
  totalStaked_not: BigInt
  totalStaked_gt: BigInt
  totalStaked_lt: BigInt
  totalStaked_gte: BigInt
  totalStaked_lte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
  isUserStaked: Boolean
  isUserStaked_not: Boolean
  isUserStaked_in: [Boolean!]
  isUserStaked_not_in: [Boolean!]
}

enum TokensStaked_orderBy {
  id
  user
  staker
  amount
  lockedUntil
  totalStaked
  timestamp
  emittedBy
  transaction
  isUserStaked
}

type Trade {
  id: ID!
  user: User!
  lender: Bytes!
  loanId: Loan!
  collateralToken: Bytes!
  loanToken: Bytes!
  positionSize: BigInt!
  borrowedAmount: BigInt!
  interestRate: BigInt!
  settlementDate: BigInt!
  entryPrice: BigInt!
  entryLeverage: BigInt!
  currentLeverage: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input Trade_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lender: Bytes
  lender_not: Bytes
  lender_in: [Bytes!]
  lender_not_in: [Bytes!]
  lender_contains: Bytes
  lender_not_contains: Bytes
  loanId: String
  loanId_not: String
  loanId_gt: String
  loanId_lt: String
  loanId_gte: String
  loanId_lte: String
  loanId_in: [String!]
  loanId_not_in: [String!]
  loanId_contains: String
  loanId_not_contains: String
  loanId_starts_with: String
  loanId_not_starts_with: String
  loanId_ends_with: String
  loanId_not_ends_with: String
  collateralToken: Bytes
  collateralToken_not: Bytes
  collateralToken_in: [Bytes!]
  collateralToken_not_in: [Bytes!]
  collateralToken_contains: Bytes
  collateralToken_not_contains: Bytes
  loanToken: Bytes
  loanToken_not: Bytes
  loanToken_in: [Bytes!]
  loanToken_not_in: [Bytes!]
  loanToken_contains: Bytes
  loanToken_not_contains: Bytes
  positionSize: BigInt
  positionSize_not: BigInt
  positionSize_gt: BigInt
  positionSize_lt: BigInt
  positionSize_gte: BigInt
  positionSize_lte: BigInt
  positionSize_in: [BigInt!]
  positionSize_not_in: [BigInt!]
  borrowedAmount: BigInt
  borrowedAmount_not: BigInt
  borrowedAmount_gt: BigInt
  borrowedAmount_lt: BigInt
  borrowedAmount_gte: BigInt
  borrowedAmount_lte: BigInt
  borrowedAmount_in: [BigInt!]
  borrowedAmount_not_in: [BigInt!]
  interestRate: BigInt
  interestRate_not: BigInt
  interestRate_gt: BigInt
  interestRate_lt: BigInt
  interestRate_gte: BigInt
  interestRate_lte: BigInt
  interestRate_in: [BigInt!]
  interestRate_not_in: [BigInt!]
  settlementDate: BigInt
  settlementDate_not: BigInt
  settlementDate_gt: BigInt
  settlementDate_lt: BigInt
  settlementDate_gte: BigInt
  settlementDate_lte: BigInt
  settlementDate_in: [BigInt!]
  settlementDate_not_in: [BigInt!]
  entryPrice: BigInt
  entryPrice_not: BigInt
  entryPrice_gt: BigInt
  entryPrice_lt: BigInt
  entryPrice_gte: BigInt
  entryPrice_lte: BigInt
  entryPrice_in: [BigInt!]
  entryPrice_not_in: [BigInt!]
  entryLeverage: BigInt
  entryLeverage_not: BigInt
  entryLeverage_gt: BigInt
  entryLeverage_lt: BigInt
  entryLeverage_gte: BigInt
  entryLeverage_lte: BigInt
  entryLeverage_in: [BigInt!]
  entryLeverage_not_in: [BigInt!]
  currentLeverage: BigInt
  currentLeverage_not: BigInt
  currentLeverage_gt: BigInt
  currentLeverage_lt: BigInt
  currentLeverage_gte: BigInt
  currentLeverage_lte: BigInt
  currentLeverage_in: [BigInt!]
  currentLeverage_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum Trade_orderBy {
  id
  user
  lender
  loanId
  collateralToken
  loanToken
  positionSize
  borrowedAmount
  interestRate
  settlementDate
  entryPrice
  entryLeverage
  currentLeverage
  timestamp
  emittedBy
  transaction
}

"""
Transaction data, including hash and timestamp
"""
type Transaction {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: BigInt!

  """
  The timestamp the transaction was confirmed
  """
  timestamp: BigInt!
  gasPrice: BigInt!

  """
  The index of this transaction within the block
  """
  index: BigInt!

  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: Bytes!
  to: Bytes
  value: BigInt!
  gasLimit: BigInt!
}

input Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  from: Bytes
  from_not: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
}

enum Transaction_orderBy {
  id
  blockNumber
  timestamp
  gasPrice
  index
  from
  to
  value
  gasLimit
}

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User {
  """
  ID is user wallet address
  """
  id: ID!

  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
  ): [Swap!]

  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLiquidityHistory_orderBy
    orderDirection: OrderDirection
    where: UserLiquidityHistory_filter
  ): [UserLiquidityHistory!]

  """
  An array of margin trade Trade events
  """
  trades(
    skip: Int = 0
    first: Int = 100
    orderBy: Trade_orderBy
    orderDirection: OrderDirection
    where: Trade_filter
  ): [Trade!]

  """
  An array of Borrow events
  """
  borrows(
    skip: Int = 0
    first: Int = 100
    orderBy: Borrow_orderBy
    orderDirection: OrderDirection
    where: Borrow_filter
  ): [Borrow!]

  """
  An array of Liquidation events linked to this user
  """
  liquidations(
    skip: Int = 0
    first: Int = 100
    orderBy: Liquidate_orderBy
    orderDirection: OrderDirection
    where: Liquidate_filter
  ): [Liquidate!]

  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans(
    skip: Int = 0
    first: Int = 100
    orderBy: Loan_orderBy
    orderDirection: OrderDirection
    where: Loan_filter
  ): [Loan!]

  """
  The lending history of a User, separated into lending pools. Explore the
  UserLendingHistory entity for more granular events.
  """
  lendingHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserLendingHistory_orderBy
    orderDirection: OrderDirection
    where: UserLendingHistory_filter
  ): [UserLendingHistory!]

  """
  The SOV Staking history of a user. This includes withdrawing vested tokens.
  Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserStakeHistory_orderBy
    orderDirection: OrderDirection
    where: UserStakeHistory_filter
  ): [UserStakeHistory!]

  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: UserRewardsEarnedHistory_orderBy
    orderDirection: OrderDirection
    where: UserRewardsEarnedHistory_filter
  ): [UserRewardsEarnedHistory!]

  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingContract_orderBy
    orderDirection: OrderDirection
    where: VestingContract_filter
  ): [VestingContract!]

  """
  Voting history of User
  """
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteCast_orderBy
    orderDirection: OrderDirection
    where: VoteCast_filter
  ): [VoteCast!]

  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
}

enum User_orderBy {
  id
  swaps
  liquidityHistory
  trades
  borrows
  liquidations
  loans
  lendingHistory
  stakeHistory
  rewardsEarnedHistory
  vestingContracts
  votes
  userTotals
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!
  user: User!
  lendingPool: LendingPool!

  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: LendingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LendingHistoryItem_filter
  ): [LendingHistoryItem!]

  """
  Total volume this User has lent to this pool over all time (in the underlying
  asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: BigInt!

  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: BigInt!
}

input UserLendingHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  lendingPool: String
  lendingPool_not: String
  lendingPool_gt: String
  lendingPool_lt: String
  lendingPool_gte: String
  lendingPool_lte: String
  lendingPool_in: [String!]
  lendingPool_not_in: [String!]
  lendingPool_contains: String
  lendingPool_not_contains: String
  lendingPool_starts_with: String
  lendingPool_not_starts_with: String
  lendingPool_ends_with: String
  lendingPool_not_ends_with: String
  totalLendVolume: BigInt
  totalLendVolume_not: BigInt
  totalLendVolume_gt: BigInt
  totalLendVolume_lt: BigInt
  totalLendVolume_gte: BigInt
  totalLendVolume_lte: BigInt
  totalLendVolume_in: [BigInt!]
  totalLendVolume_not_in: [BigInt!]
  totalUnlendVolume: BigInt
  totalUnlendVolume_not: BigInt
  totalUnlendVolume_gt: BigInt
  totalUnlendVolume_lt: BigInt
  totalUnlendVolume_gte: BigInt
  totalUnlendVolume_lte: BigInt
  totalUnlendVolume_in: [BigInt!]
  totalUnlendVolume_not_in: [BigInt!]
}

enum UserLendingHistory_orderBy {
  id
  user
  lendingPool
  lendingHistory
  totalLendVolume
  totalUnlendVolume
}

"""
This entity stores one Users history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory {
  id: ID!
  user: User!
  poolToken: PoolToken!
  totalAsset0LiquidityAdded: BigInt!
  totalAsset0LiquidityRemoved: BigInt!
  totalAsset1LiquidityAdded: BigInt!
  totalAsset1LiquidityRemoved: BigInt!
  liquidityHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: LiquidityHistoryItem_orderBy
    orderDirection: OrderDirection
    where: LiquidityHistoryItem_filter
  ): [LiquidityHistoryItem!]
}

input UserLiquidityHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  poolToken: String
  poolToken_not: String
  poolToken_gt: String
  poolToken_lt: String
  poolToken_gte: String
  poolToken_lte: String
  poolToken_in: [String!]
  poolToken_not_in: [String!]
  poolToken_contains: String
  poolToken_not_contains: String
  poolToken_starts_with: String
  poolToken_not_starts_with: String
  poolToken_ends_with: String
  poolToken_not_ends_with: String
  totalAsset0LiquidityAdded: BigInt
  totalAsset0LiquidityAdded_not: BigInt
  totalAsset0LiquidityAdded_gt: BigInt
  totalAsset0LiquidityAdded_lt: BigInt
  totalAsset0LiquidityAdded_gte: BigInt
  totalAsset0LiquidityAdded_lte: BigInt
  totalAsset0LiquidityAdded_in: [BigInt!]
  totalAsset0LiquidityAdded_not_in: [BigInt!]
  totalAsset0LiquidityRemoved: BigInt
  totalAsset0LiquidityRemoved_not: BigInt
  totalAsset0LiquidityRemoved_gt: BigInt
  totalAsset0LiquidityRemoved_lt: BigInt
  totalAsset0LiquidityRemoved_gte: BigInt
  totalAsset0LiquidityRemoved_lte: BigInt
  totalAsset0LiquidityRemoved_in: [BigInt!]
  totalAsset0LiquidityRemoved_not_in: [BigInt!]
  totalAsset1LiquidityAdded: BigInt
  totalAsset1LiquidityAdded_not: BigInt
  totalAsset1LiquidityAdded_gt: BigInt
  totalAsset1LiquidityAdded_lt: BigInt
  totalAsset1LiquidityAdded_gte: BigInt
  totalAsset1LiquidityAdded_lte: BigInt
  totalAsset1LiquidityAdded_in: [BigInt!]
  totalAsset1LiquidityAdded_not_in: [BigInt!]
  totalAsset1LiquidityRemoved: BigInt
  totalAsset1LiquidityRemoved_not: BigInt
  totalAsset1LiquidityRemoved_gt: BigInt
  totalAsset1LiquidityRemoved_lt: BigInt
  totalAsset1LiquidityRemoved_gte: BigInt
  totalAsset1LiquidityRemoved_lte: BigInt
  totalAsset1LiquidityRemoved_in: [BigInt!]
  totalAsset1LiquidityRemoved_not_in: [BigInt!]
}

enum UserLiquidityHistory_orderBy {
  id
  user
  poolToken
  totalAsset0LiquidityAdded
  totalAsset0LiquidityRemoved
  totalAsset1LiquidityAdded
  totalAsset1LiquidityRemoved
  liquidityHistory
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory {
  id: ID!
  user: User!

  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: BigInt!

  """
  This is incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: BigInt!

  """
  This is incremented by EarnReward and RewardClaimed events, and set to 0 by RewardWithdrawn events
  """
  availableRewardSov: BigInt!
  rewardsEarnedHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardsEarnedHistoryItem_orderBy
    orderDirection: OrderDirection
    where: RewardsEarnedHistoryItem_filter
  ): [RewardsEarnedHistoryItem!]
}

input UserRewardsEarnedHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalFeesAndRewardsEarned: BigInt
  totalFeesAndRewardsEarned_not: BigInt
  totalFeesAndRewardsEarned_gt: BigInt
  totalFeesAndRewardsEarned_lt: BigInt
  totalFeesAndRewardsEarned_gte: BigInt
  totalFeesAndRewardsEarned_lte: BigInt
  totalFeesAndRewardsEarned_in: [BigInt!]
  totalFeesAndRewardsEarned_not_in: [BigInt!]
  availableTradingRewards: BigInt
  availableTradingRewards_not: BigInt
  availableTradingRewards_gt: BigInt
  availableTradingRewards_lt: BigInt
  availableTradingRewards_gte: BigInt
  availableTradingRewards_lte: BigInt
  availableTradingRewards_in: [BigInt!]
  availableTradingRewards_not_in: [BigInt!]
  availableRewardSov: BigInt
  availableRewardSov_not: BigInt
  availableRewardSov_gt: BigInt
  availableRewardSov_lt: BigInt
  availableRewardSov_gte: BigInt
  availableRewardSov_lte: BigInt
  availableRewardSov_in: [BigInt!]
  availableRewardSov_not_in: [BigInt!]
}

enum UserRewardsEarnedHistory_orderBy {
  id
  user
  totalFeesAndRewardsEarned
  availableTradingRewards
  availableRewardSov
  rewardsEarnedHistory
}

type UserStakeHistory {
  id: ID!
  user: User!
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistoryItem_orderBy
    orderDirection: OrderDirection
    where: StakeHistoryItem_filter
  ): [StakeHistoryItem!]
  totalStaked: BigInt!
  totalWithdrawn: BigInt!
  totalRemaining: BigInt!
}

input UserStakeHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalStaked: BigInt
  totalStaked_not: BigInt
  totalStaked_gt: BigInt
  totalStaked_lt: BigInt
  totalStaked_gte: BigInt
  totalStaked_lte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_not_in: [BigInt!]
  totalWithdrawn: BigInt
  totalWithdrawn_not: BigInt
  totalWithdrawn_gt: BigInt
  totalWithdrawn_lt: BigInt
  totalWithdrawn_gte: BigInt
  totalWithdrawn_lte: BigInt
  totalWithdrawn_in: [BigInt!]
  totalWithdrawn_not_in: [BigInt!]
  totalRemaining: BigInt
  totalRemaining_not: BigInt
  totalRemaining_gt: BigInt
  totalRemaining_lt: BigInt
  totalRemaining_gte: BigInt
  totalRemaining_lte: BigInt
  totalRemaining_in: [BigInt!]
  totalRemaining_not_in: [BigInt!]
}

enum UserStakeHistory_orderBy {
  id
  user
  stakeHistory
  totalStaked
  totalWithdrawn
  totalRemaining
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: BigDecimal!
  totalCloseWithSwapVolumeUsd: BigDecimal!
  totalDepositCollateralVolumeUsd: BigDecimal!
  totalLiquidateVolumeUsd: BigDecimal!
  totalAmmVolumeUsd: BigDecimal!
  totalAmmLpFeesUsd: BigDecimal!
  totalAmmStakerFeesUsd: BigDecimal!
  totalTradingFeesUsd: BigDecimal!
  totalLendingFeesUsd: BigDecimal!
  totalBorrowingFeesUsd: BigDecimal!
  totalLendVolumeUsd: BigDecimal!
  totalUnlendVolumeUsd: BigDecimal!
  totalBorrowVolumeUsd: BigDecimal!
  totalCloseWithDepositVolumeUsd: BigDecimal!
}

input UserTotal_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  totalMarginTradeVolumeUsd: BigDecimal
  totalMarginTradeVolumeUsd_not: BigDecimal
  totalMarginTradeVolumeUsd_gt: BigDecimal
  totalMarginTradeVolumeUsd_lt: BigDecimal
  totalMarginTradeVolumeUsd_gte: BigDecimal
  totalMarginTradeVolumeUsd_lte: BigDecimal
  totalMarginTradeVolumeUsd_in: [BigDecimal!]
  totalMarginTradeVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd: BigDecimal
  totalCloseWithSwapVolumeUsd_not: BigDecimal
  totalCloseWithSwapVolumeUsd_gt: BigDecimal
  totalCloseWithSwapVolumeUsd_lt: BigDecimal
  totalCloseWithSwapVolumeUsd_gte: BigDecimal
  totalCloseWithSwapVolumeUsd_lte: BigDecimal
  totalCloseWithSwapVolumeUsd_in: [BigDecimal!]
  totalCloseWithSwapVolumeUsd_not_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd: BigDecimal
  totalDepositCollateralVolumeUsd_not: BigDecimal
  totalDepositCollateralVolumeUsd_gt: BigDecimal
  totalDepositCollateralVolumeUsd_lt: BigDecimal
  totalDepositCollateralVolumeUsd_gte: BigDecimal
  totalDepositCollateralVolumeUsd_lte: BigDecimal
  totalDepositCollateralVolumeUsd_in: [BigDecimal!]
  totalDepositCollateralVolumeUsd_not_in: [BigDecimal!]
  totalLiquidateVolumeUsd: BigDecimal
  totalLiquidateVolumeUsd_not: BigDecimal
  totalLiquidateVolumeUsd_gt: BigDecimal
  totalLiquidateVolumeUsd_lt: BigDecimal
  totalLiquidateVolumeUsd_gte: BigDecimal
  totalLiquidateVolumeUsd_lte: BigDecimal
  totalLiquidateVolumeUsd_in: [BigDecimal!]
  totalLiquidateVolumeUsd_not_in: [BigDecimal!]
  totalAmmVolumeUsd: BigDecimal
  totalAmmVolumeUsd_not: BigDecimal
  totalAmmVolumeUsd_gt: BigDecimal
  totalAmmVolumeUsd_lt: BigDecimal
  totalAmmVolumeUsd_gte: BigDecimal
  totalAmmVolumeUsd_lte: BigDecimal
  totalAmmVolumeUsd_in: [BigDecimal!]
  totalAmmVolumeUsd_not_in: [BigDecimal!]
  totalAmmLpFeesUsd: BigDecimal
  totalAmmLpFeesUsd_not: BigDecimal
  totalAmmLpFeesUsd_gt: BigDecimal
  totalAmmLpFeesUsd_lt: BigDecimal
  totalAmmLpFeesUsd_gte: BigDecimal
  totalAmmLpFeesUsd_lte: BigDecimal
  totalAmmLpFeesUsd_in: [BigDecimal!]
  totalAmmLpFeesUsd_not_in: [BigDecimal!]
  totalAmmStakerFeesUsd: BigDecimal
  totalAmmStakerFeesUsd_not: BigDecimal
  totalAmmStakerFeesUsd_gt: BigDecimal
  totalAmmStakerFeesUsd_lt: BigDecimal
  totalAmmStakerFeesUsd_gte: BigDecimal
  totalAmmStakerFeesUsd_lte: BigDecimal
  totalAmmStakerFeesUsd_in: [BigDecimal!]
  totalAmmStakerFeesUsd_not_in: [BigDecimal!]
  totalTradingFeesUsd: BigDecimal
  totalTradingFeesUsd_not: BigDecimal
  totalTradingFeesUsd_gt: BigDecimal
  totalTradingFeesUsd_lt: BigDecimal
  totalTradingFeesUsd_gte: BigDecimal
  totalTradingFeesUsd_lte: BigDecimal
  totalTradingFeesUsd_in: [BigDecimal!]
  totalTradingFeesUsd_not_in: [BigDecimal!]
  totalLendingFeesUsd: BigDecimal
  totalLendingFeesUsd_not: BigDecimal
  totalLendingFeesUsd_gt: BigDecimal
  totalLendingFeesUsd_lt: BigDecimal
  totalLendingFeesUsd_gte: BigDecimal
  totalLendingFeesUsd_lte: BigDecimal
  totalLendingFeesUsd_in: [BigDecimal!]
  totalLendingFeesUsd_not_in: [BigDecimal!]
  totalBorrowingFeesUsd: BigDecimal
  totalBorrowingFeesUsd_not: BigDecimal
  totalBorrowingFeesUsd_gt: BigDecimal
  totalBorrowingFeesUsd_lt: BigDecimal
  totalBorrowingFeesUsd_gte: BigDecimal
  totalBorrowingFeesUsd_lte: BigDecimal
  totalBorrowingFeesUsd_in: [BigDecimal!]
  totalBorrowingFeesUsd_not_in: [BigDecimal!]
  totalLendVolumeUsd: BigDecimal
  totalLendVolumeUsd_not: BigDecimal
  totalLendVolumeUsd_gt: BigDecimal
  totalLendVolumeUsd_lt: BigDecimal
  totalLendVolumeUsd_gte: BigDecimal
  totalLendVolumeUsd_lte: BigDecimal
  totalLendVolumeUsd_in: [BigDecimal!]
  totalLendVolumeUsd_not_in: [BigDecimal!]
  totalUnlendVolumeUsd: BigDecimal
  totalUnlendVolumeUsd_not: BigDecimal
  totalUnlendVolumeUsd_gt: BigDecimal
  totalUnlendVolumeUsd_lt: BigDecimal
  totalUnlendVolumeUsd_gte: BigDecimal
  totalUnlendVolumeUsd_lte: BigDecimal
  totalUnlendVolumeUsd_in: [BigDecimal!]
  totalUnlendVolumeUsd_not_in: [BigDecimal!]
  totalBorrowVolumeUsd: BigDecimal
  totalBorrowVolumeUsd_not: BigDecimal
  totalBorrowVolumeUsd_gt: BigDecimal
  totalBorrowVolumeUsd_lt: BigDecimal
  totalBorrowVolumeUsd_gte: BigDecimal
  totalBorrowVolumeUsd_lte: BigDecimal
  totalBorrowVolumeUsd_in: [BigDecimal!]
  totalBorrowVolumeUsd_not_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd: BigDecimal
  totalCloseWithDepositVolumeUsd_not: BigDecimal
  totalCloseWithDepositVolumeUsd_gt: BigDecimal
  totalCloseWithDepositVolumeUsd_lt: BigDecimal
  totalCloseWithDepositVolumeUsd_gte: BigDecimal
  totalCloseWithDepositVolumeUsd_lte: BigDecimal
  totalCloseWithDepositVolumeUsd_in: [BigDecimal!]
  totalCloseWithDepositVolumeUsd_not_in: [BigDecimal!]
}

enum UserTotal_orderBy {
  id
  user
  totalMarginTradeVolumeUsd
  totalCloseWithSwapVolumeUsd
  totalDepositCollateralVolumeUsd
  totalLiquidateVolumeUsd
  totalAmmVolumeUsd
  totalAmmLpFeesUsd
  totalAmmStakerFeesUsd
  totalTradingFeesUsd
  totalLendingFeesUsd
  totalBorrowingFeesUsd
  totalLendVolumeUsd
  totalUnlendVolumeUsd
  totalBorrowVolumeUsd
  totalCloseWithDepositVolumeUsd
}

type VestingContract {
  id: ID!
  user: User!
  createdAtTimestamp: BigInt!
  cliff: BigInt
  duration: BigInt
  startingBalance: BigInt!
  currentBalance: BigInt!
  type: VestingContractType!
  emittedBy: Bytes!
  createdAtTransaction: Transaction!
  stakeHistory(
    skip: Int = 0
    first: Int = 100
    orderBy: VestingHistoryItem_orderBy
    orderDirection: OrderDirection
    where: VestingHistoryItem_filter
  ): [VestingHistoryItem!]
}

input VestingContract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_not_contains: String
  user_starts_with: String
  user_not_starts_with: String
  user_ends_with: String
  user_not_ends_with: String
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  cliff: BigInt
  cliff_not: BigInt
  cliff_gt: BigInt
  cliff_lt: BigInt
  cliff_gte: BigInt
  cliff_lte: BigInt
  cliff_in: [BigInt!]
  cliff_not_in: [BigInt!]
  duration: BigInt
  duration_not: BigInt
  duration_gt: BigInt
  duration_lt: BigInt
  duration_gte: BigInt
  duration_lte: BigInt
  duration_in: [BigInt!]
  duration_not_in: [BigInt!]
  startingBalance: BigInt
  startingBalance_not: BigInt
  startingBalance_gt: BigInt
  startingBalance_lt: BigInt
  startingBalance_gte: BigInt
  startingBalance_lte: BigInt
  startingBalance_in: [BigInt!]
  startingBalance_not_in: [BigInt!]
  currentBalance: BigInt
  currentBalance_not: BigInt
  currentBalance_gt: BigInt
  currentBalance_lt: BigInt
  currentBalance_gte: BigInt
  currentBalance_lte: BigInt
  currentBalance_in: [BigInt!]
  currentBalance_not_in: [BigInt!]
  type: VestingContractType
  type_not: VestingContractType
  type_in: [VestingContractType!]
  type_not_in: [VestingContractType!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  createdAtTransaction: String
  createdAtTransaction_not: String
  createdAtTransaction_gt: String
  createdAtTransaction_lt: String
  createdAtTransaction_gte: String
  createdAtTransaction_lte: String
  createdAtTransaction_in: [String!]
  createdAtTransaction_not_in: [String!]
  createdAtTransaction_contains: String
  createdAtTransaction_not_contains: String
  createdAtTransaction_starts_with: String
  createdAtTransaction_not_starts_with: String
  createdAtTransaction_ends_with: String
  createdAtTransaction_not_ends_with: String
}

enum VestingContract_orderBy {
  id
  user
  createdAtTimestamp
  cliff
  duration
  startingBalance
  currentBalance
  type
  emittedBy
  createdAtTransaction
  stakeHistory
}

enum VestingContractType {
  Origins
  Genesis
  Fish
  FishTeam
  Team
  Rewards
}

type VestingHistoryItem {
  id: ID!
  action: VestingHistoryItemAction!
  staker: VestingContract!
  amount: BigInt!
  lockedUntil: BigInt!
  totalStaked: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input VestingHistoryItem_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  action: VestingHistoryItemAction
  action_not: VestingHistoryItemAction
  action_in: [VestingHistoryItemAction!]
  action_not_in: [VestingHistoryItemAction!]
  staker: String
  staker_not: String
  staker_gt: String
  staker_lt: String
  staker_gte: String
  staker_lte: String
  staker_in: [String!]
  staker_not_in: [String!]
  staker_contains: String
  staker_not_contains: String
  staker_starts_with: String
  staker_not_starts_with: String
  staker_ends_with: String
  staker_not_ends_with: String
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lockedUntil: BigInt
  lockedUntil_not: BigInt
  lockedUntil_gt: BigInt
  lockedUntil_lt: BigInt
  lockedUntil_gte: BigInt
  lockedUntil_lte: BigInt
  lockedUntil_in: [BigInt!]
  lockedUntil_not_in: [BigInt!]
  totalStaked: BigInt
  totalStaked_not: BigInt
  totalStaked_gt: BigInt
  totalStaked_lt: BigInt
  totalStaked_gte: BigInt
  totalStaked_lte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum VestingHistoryItem_orderBy {
  id
  action
  staker
  amount
  lockedUntil
  totalStaked
  timestamp
  emittedBy
  transaction
}

enum VestingHistoryItemAction {
  TokensStaked
  TeamTokensRevoked
  TokensWithdrawn
}

type VoteCast {
  id: ID!
  voter: User!
  proposalId: BigInt!
  proposal: Proposal!
  support: Boolean!
  votes: BigInt!
  timestamp: BigInt!
  emittedBy: Bytes!
  transaction: Transaction!
}

input VoteCast_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  voter: String
  voter_not: String
  voter_gt: String
  voter_lt: String
  voter_gte: String
  voter_lte: String
  voter_in: [String!]
  voter_not_in: [String!]
  voter_contains: String
  voter_not_contains: String
  voter_starts_with: String
  voter_not_starts_with: String
  voter_ends_with: String
  voter_not_ends_with: String
  proposalId: BigInt
  proposalId_not: BigInt
  proposalId_gt: BigInt
  proposalId_lt: BigInt
  proposalId_gte: BigInt
  proposalId_lte: BigInt
  proposalId_in: [BigInt!]
  proposalId_not_in: [BigInt!]
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_not_contains: String
  proposal_starts_with: String
  proposal_not_starts_with: String
  proposal_ends_with: String
  proposal_not_ends_with: String
  support: Boolean
  support_not: Boolean
  support_in: [Boolean!]
  support_not_in: [Boolean!]
  votes: BigInt
  votes_not: BigInt
  votes_gt: BigInt
  votes_lt: BigInt
  votes_gte: BigInt
  votes_lte: BigInt
  votes_in: [BigInt!]
  votes_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  emittedBy: Bytes
  emittedBy_not: Bytes
  emittedBy_in: [Bytes!]
  emittedBy_not_in: [Bytes!]
  emittedBy_contains: Bytes
  emittedBy_not_contains: Bytes
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_not_contains: String
  transaction_starts_with: String
  transaction_not_starts_with: String
  transaction_ends_with: String
  transaction_not_ends_with: String
}

enum VoteCast_orderBy {
  id
  voter
  proposalId
  proposal
  support
  votes
  timestamp
  emittedBy
  transaction
}
